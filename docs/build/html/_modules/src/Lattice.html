

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>src.Lattice &mdash; pyLattice 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pyLattice
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">src</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cell_geometries.html">Tutoriel : créer une structure BCC</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyLattice</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">src.Lattice</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for src.Lattice</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Lattice.py</span>

<span class="sd">Generate lattice structures with various parameters and properties.</span>

<span class="sd">This module provides the Lattice class, which allows for the creation and manipulation of lattice structures,</span>
<span class="sd">including the definition of cell dimensions, material properties, and gradient settings. It also supports simulation methods and uncertainty handling.</span>

<span class="sd">Created in 2023 by Cadart Thomas, University of technology Belfort Montbéliard.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">statistics</span> <span class="kn">import</span> <span class="n">mean</span>

<span class="kn">import</span> <span class="nn">joblib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">splu</span>
<span class="kn">import</span> <span class="nn">gmsh</span>

<span class="kn">from</span> <span class="nn">cell</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">timing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">_validate_inputs</span>
<span class="kn">from</span> <span class="nn">gradient_properties</span> <span class="kn">import</span> <span class="n">get_grad_settings</span><span class="p">,</span> <span class="n">grad_material_setting</span><span class="p">,</span> <span class="n">grad_settings_constant</span>

<span class="n">timing</span> <span class="o">=</span> <span class="n">Timing</span><span class="p">()</span>


<div class="viewcode-block" id="Lattice">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice">[docs]</a>
<span class="k">class</span> <span class="nc">Lattice</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate lattice structures with a lot of different parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_size_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cell_size_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cell_size_z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">num_cells_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_cells_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_cells_z</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">geom_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">radii</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">material_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                 <span class="n">grad_radius_property</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">grad_dim_property</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">grad_mat_property</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">uncertainty_node</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">enable_periodicity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">eraser_blocks</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">mesh_object</span><span class="p">:</span> <span class="s2">&quot;mesh&quot;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">symmetry_lattice</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">enable_simulation_properties</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor general for the Lattice class.</span>

<span class="sd">        Parameter:</span>
<span class="sd">        -----------</span>
<span class="sd">        cell_size_x: float</span>
<span class="sd">        cell_size_y: float</span>
<span class="sd">        cell_size_z: float</span>
<span class="sd">            Dimension in each direction of the intial cell in the structure</span>

<span class="sd">        num_cells_x: integer</span>
<span class="sd">        num_cells_y: integer</span>
<span class="sd">        num_cells_z: integer</span>
<span class="sd">            Number of cells in each direction in the structure</span>

<span class="sd">        geom_types: list of string</span>
<span class="sd">            Name of geometry types of the cell structure.</span>
<span class="sd">        radii: list of float</span>
<span class="sd">            Initial radii geometry</span>
<span class="sd">        material_name: string</span>
<span class="sd">            Name of the default material in the lattice structure (&#39;Ti-6Al-4V&#39;, &#39;VeroClear&#39;...)</span>
<span class="sd">            Possible to add more material in the Material.py file</span>

<span class="sd">        Gradient properties</span>
<span class="sd">        grad_radius_property: array of data as [GradDimRule,GradDimDirection,GradDimParameters]</span>
<span class="sd">            radii gradient on the lattice structure</span>
<span class="sd">        grad_dim_property: array of data as [GradRadRule,GradRadDirection,GradRadParameters]</span>
<span class="sd">            Cell dimension gradient on the lattice structure</span>
<span class="sd">                GradRule =&gt; constant, linear, parabolic, sinusoide, exponential</span>
<span class="sd">                GradDirection =&gt; [bool,bool,bool] set integer to True to active gradient in direction [X,Y,Z] False inactive</span>
<span class="sd">                GradParameters =&gt; [float, float, float] variable in the gradient rule for each direction [X,Y,Z]</span>
<span class="sd">        grad_mat_property: array of data as [Multimat,GradMaterialDirection]</span>
<span class="sd">            Material gradient on the lattice structure</span>
<span class="sd">                Multimat =&gt; Type of multimaterial (0: inactive / 1: multimat by layer / -1: Full random)</span>

<span class="sd">        uncertainty_node: float</span>
<span class="sd">            Control if adding uncertainties on node position</span>
<span class="sd">        enable_periodicity: boolean</span>
<span class="sd">            Applying enable_periodicity on the outer box of the lattice structure to calculate penalization method</span>
<span class="sd">        eraser_blocks: list of float in dim 6</span>
<span class="sd">            (xStart, yStart, zStart, xDim, yDim, zDim) of the erased region</span>
<span class="sd">        mesh_object: mesh</span>
<span class="sd">            Mesh object to check if the lattice structure is inside the mesh</span>
<span class="sd">        symmetry_lattice: dictionary {&quot;sym_plane&quot;: string, &quot;sym_point&quot;: tuple}</span>
<span class="sd">            Data to apply symmetry on the lattice structure</span>
<span class="sd">        enable_simulation_properties: boolean</span>
<span class="sd">            If True, the lattice will generate properties necessary for simulation and optimization</span>
<span class="sd">            And joint beam penalization method will be applied</span>
<span class="sd">        verbose: boolean</span>
<span class="sd">            If True, print statistics and information during the lattice generation process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_validate_inputs</span><span class="p">(</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="n">cell_size_y</span><span class="p">,</span> <span class="n">cell_size_z</span><span class="p">,</span> <span class="n">num_cells_x</span><span class="p">,</span> <span class="n">num_cells_y</span><span class="p">,</span> <span class="n">num_cells_z</span><span class="p">,</span>
                         <span class="n">geom_types</span><span class="p">,</span> <span class="n">radii</span><span class="p">,</span> <span class="n">material_name</span><span class="p">,</span> <span class="n">grad_radius_property</span><span class="p">,</span> <span class="n">grad_dim_property</span><span class="p">,</span> <span class="n">grad_mat_property</span><span class="p">,</span>
                         <span class="n">uncertainty_node</span><span class="p">,</span> <span class="n">enable_periodicity</span><span class="p">,</span> <span class="n">eraser_blocks</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name_lattice</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Lattice&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_tags</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_tags</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corner_tags</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice_dimension_dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_schur_complement</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objectif_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span> <span class="o">=</span> <span class="n">cell_size_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span> <span class="o">=</span> <span class="n">cell_size_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span> <span class="o">=</span> <span class="n">cell_size_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span> <span class="o">=</span> <span class="n">num_cells_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span> <span class="o">=</span> <span class="n">num_cells_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span> <span class="o">=</span> <span class="n">num_cells_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span> <span class="o">=</span> <span class="n">geom_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radii</span> <span class="o">=</span> <span class="n">radii</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material_name</span> <span class="o">=</span> <span class="n">material_name</span>
        <span class="k">if</span> <span class="n">grad_radius_property</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad_radius</span> <span class="o">=</span> <span class="n">get_grad_settings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">,</span>
                                                 <span class="n">grad_radius_property</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad_radius</span> <span class="o">=</span> <span class="n">grad_settings_constant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grad_dim_property</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad_dim</span> <span class="o">=</span> <span class="n">get_grad_settings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">,</span> <span class="n">grad_dim_property</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad_dim</span> <span class="o">=</span> <span class="n">grad_settings_constant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grad_mat_property</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad_mat</span> <span class="o">=</span> <span class="n">grad_material_setting</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">,</span>
                                                  <span class="n">grad_mat_property</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad_mat</span> <span class="o">=</span> <span class="n">grad_settings_constant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">,</span>
                                                   <span class="n">material_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enable_simulation_properties</span> <span class="o">=</span> <span class="n">enable_simulation_properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_size_lattice</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uncertainty_node</span> <span class="o">=</span> <span class="n">uncertainty_node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enable_periodicity</span> <span class="o">=</span> <span class="n">enable_periodicity</span>  <span class="c1"># Warning not working for graded structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eraser_blocks</span> <span class="o">=</span> <span class="n">eraser_blocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_object</span> <span class="o">=</span> <span class="n">mesh_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Simulation necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_DOF</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Free DOF gradient conjugate gradient method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_index_boundary</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_displacement_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_value_objective</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_relative_density_constraint</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_continuity_constraint</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_density_poly</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_density_poly_deriv</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_DOF_per_node</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Number of DOF per node (3 translation + 3 rotation)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter_optimization</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kriging_model_relative_density</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">penalization_coefficient</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.5</span>  <span class="c1"># Fixed with previous optimization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_lattice</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Generate global structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_lattice</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">symmetry_lattice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_symmetry</span><span class="p">(</span><span class="n">symmetry_lattice</span><span class="p">[</span><span class="s2">&quot;sym_plane&quot;</span><span class="p">],</span> <span class="n">symmetry_lattice</span><span class="p">[</span><span class="s2">&quot;sym_point&quot;</span><span class="p">])</span>

        <span class="c1"># Generate important data for the lattice structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_tag_classification</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_lattice_dimensions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">define_beam_node_index</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">define_cell_index</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">define_cell_neighbours</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_point_local_tag</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_tag_all_point</span><span class="p">()</span>

        <span class="c1"># Simulation necessaries</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_simulation_properties</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_all_angles</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_beam_node_mod</span><span class="p">()</span>

            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Material name_lattice must be defined for simulation properties.&quot;</span>
            <span class="c1"># Define global indexation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">define_node_index_boundary</span><span class="p">()</span>
            <span class="c1"># Optimization necessary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_relative_density_model</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_statistics_lattice</span><span class="p">()</span>

<div class="viewcode-block" id="Lattice.from_json">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.from_json">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="s1">&#39;Path&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Lattice&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a lattice object from a JSON file.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        file_path: str</span>
<span class="sd">            Path to the JSON file containing lattice data.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        Lattice</span>
<span class="sd">            The loaded lattice object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

        <span class="c1"># Geometry</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">cell_size</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cell_size&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">number_of_cells</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;number_of_cells&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="n">cell_size_x</span> <span class="o">=</span> <span class="n">cell_size</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="n">cell_size_y</span> <span class="o">=</span> <span class="n">cell_size</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="n">cell_size_z</span> <span class="o">=</span> <span class="n">cell_size</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
        <span class="n">num_cells_x</span> <span class="o">=</span> <span class="n">number_of_cells</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="n">num_cells_y</span> <span class="o">=</span> <span class="n">number_of_cells</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="n">num_cells_z</span> <span class="o">=</span> <span class="n">number_of_cells</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
        <span class="n">radii</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;radii&quot;</span><span class="p">)</span>
        <span class="n">geom_types</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geom_types&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="n">cell_size_y</span><span class="p">,</span> <span class="n">cell_size_z</span><span class="p">,</span> <span class="n">num_cells_x</span><span class="p">,</span> <span class="n">num_cells_y</span><span class="p">,</span> <span class="n">num_cells_z</span><span class="p">,</span> <span class="n">radii</span><span class="p">,</span> <span class="n">geom_types</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing geometry parameters in JSON file.&quot;</span><span class="p">)</span>

        <span class="c1"># Gradient</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">radius_grad</span> <span class="o">=</span> <span class="n">gradient</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;radii&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">dim_grad</span> <span class="o">=</span> <span class="n">gradient</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cell_dimension&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">mat_grad</span> <span class="o">=</span> <span class="n">gradient</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;material&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="n">grad_radius_property</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rule&quot;</span><span class="p">,</span> <span class="s2">&quot;constant&quot;</span><span class="p">),</span>
            <span class="p">[</span><span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction_x&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
             <span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction_y&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
             <span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction_z&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)],</span>
            <span class="p">[</span><span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameter_x&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
             <span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameter_y&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
             <span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameter_z&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span>
        <span class="p">]</span>

        <span class="n">grad_dim_property</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rule&quot;</span><span class="p">,</span> <span class="s2">&quot;constant&quot;</span><span class="p">),</span>
            <span class="p">[</span><span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction_x&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
             <span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction_y&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
             <span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction_z&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)],</span>
            <span class="p">[</span><span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameter_x&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
             <span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameter_y&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
             <span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameter_z&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span>
        <span class="p">]</span>

        <span class="n">grad_mat_property</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">mat_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type_beam&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">mat_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Supplementary</span>
        <span class="n">supplementary</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;suplementary&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">uncertainty_node</span> <span class="o">=</span> <span class="n">supplementary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;node_uncertainty&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># Erased blocks</span>
        <span class="n">erased_blocks_json</span> <span class="o">=</span> <span class="n">supplementary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;erased_blocks&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">erased_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">erased_blocks_json</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;start_point&quot;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dimensions_block&quot;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">erased_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                <span class="n">start</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">start</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">start</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
                <span class="n">dim</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">dim</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">dim</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">erased_blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">erased_blocks</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Symmetry</span>
        <span class="n">symmetries</span> <span class="o">=</span> <span class="n">supplementary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;symmetries&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">symmetry_lattice</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">symmetries</span><span class="p">:</span>
            <span class="n">sym_plane</span> <span class="o">=</span> <span class="n">symmetries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;plane&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">sym_point</span> <span class="o">=</span> <span class="n">symmetries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;reference_point&quot;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">symmetry_lattice</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;sym_plane&quot;</span><span class="p">:</span> <span class="n">sym_plane</span><span class="p">,</span>
                <span class="s2">&quot;sym_point&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">sym_point</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
                              <span class="n">sym_point</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
                              <span class="n">sym_point</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
            <span class="p">}</span>

        <span class="c1"># Simulation activation</span>
        <span class="n">sim_params</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;simulation_parameters&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">enable_simulation_properties</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">sim_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;enable&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
        <span class="n">material_name</span> <span class="o">=</span> <span class="n">sim_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;material&quot;</span><span class="p">,</span> <span class="s2">&quot;VeroClear&quot;</span><span class="p">)</span>
        <span class="n">periodicity</span> <span class="o">=</span> <span class="n">sim_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;periodicity&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="n">cell_size_y</span><span class="p">,</span> <span class="n">cell_size_z</span><span class="p">,</span>
                   <span class="n">num_cells_x</span><span class="p">,</span> <span class="n">num_cells_y</span><span class="p">,</span> <span class="n">num_cells_z</span><span class="p">,</span>
                   <span class="n">geom_types</span><span class="p">,</span> <span class="n">radii</span><span class="p">,</span>
                   <span class="n">material_name</span><span class="o">=</span><span class="n">material_name</span><span class="p">,</span>
                   <span class="n">grad_radius_property</span><span class="o">=</span><span class="n">grad_radius_property</span><span class="p">,</span>
                   <span class="n">grad_dim_property</span><span class="o">=</span><span class="n">grad_dim_property</span><span class="p">,</span>
                   <span class="n">grad_mat_property</span><span class="o">=</span><span class="n">grad_mat_property</span><span class="p">,</span>
                   <span class="n">uncertainty_node</span><span class="o">=</span><span class="n">uncertainty_node</span><span class="p">,</span>
                   <span class="n">enable_periodicity</span><span class="o">=</span><span class="n">periodicity</span><span class="p">,</span>
                   <span class="n">eraser_blocks</span><span class="o">=</span><span class="n">erased_blocks</span><span class="p">,</span>
                   <span class="n">symmetry_lattice</span><span class="o">=</span><span class="n">symmetry_lattice</span><span class="p">,</span>
                   <span class="n">enable_simulation_properties</span><span class="o">=</span><span class="n">enable_simulation_properties</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.pickle_lattice">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.pickle_lattice">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">pickle_lattice</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;LatticeObject&quot;</span><span class="p">,</span> <span class="n">folder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Saved_Lattice&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Lattice&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a lattice pickle from a file.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        file_name: str</span>
<span class="sd">            Name of the file to load (with or without the &#39;.pkl&#39; extension).</span>
<span class="sd">        folder: str</span>
<span class="sd">            Folder where the file is located.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        Lattice</span>
<span class="sd">            The loaded lattice object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.pkl&quot;</span><span class="p">):</span>
            <span class="n">file_name</span> <span class="o">+=</span> <span class="s2">&quot;.pkl&quot;</span>

        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The file </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lattice loaded successfully from </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lattice</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Lattice name_lattice: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name_lattice</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Dimensions: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">size_x</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">size_y</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">size_z</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Number of cells: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Cell size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Material: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">material_name</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;radii: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">string</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">generate_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate cells in the lattice structure based on cell size, number of cells, geometry types, and radii.</span>
<span class="sd">        Gradient informations and erased regions are also considered during cell generation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_cell_start_init</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_cell_start_init</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">z_cell_start_init</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x_cell_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_cell_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">z_cell_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pos_cell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x_cell_start</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_dim</span><span class="p">[</span><span class="n">pos_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_cell_start</span> <span class="o">=</span> <span class="n">x_cell_start_init</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">y_cell_start</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_dim</span><span class="p">[</span><span class="n">pos_cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y_cell_start</span> <span class="o">=</span> <span class="n">y_cell_start_init</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">z_cell_start</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_dim</span><span class="p">[</span><span class="n">pos_cell</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">z_cell_start</span> <span class="o">=</span> <span class="n">z_cell_start_init</span>
                    <span class="n">pos_cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                    <span class="n">initial_cell_size</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span><span class="p">]</span>
                    <span class="n">start_cell_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_cell_start</span><span class="p">,</span> <span class="n">y_cell_start</span><span class="p">,</span> <span class="n">z_cell_start</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_not_in_erased_region</span><span class="p">(</span><span class="n">start_cell_pos</span><span class="p">):</span>
                        <span class="n">radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radii</span>
                        <span class="n">new_cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">pos_cell</span><span class="p">,</span> <span class="n">initial_cell_size</span><span class="p">,</span> <span class="n">start_cell_pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">grad_radius</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertainty_node</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cell_in_mesh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">new_cell</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_hybrid_collision</span><span class="p">()</span>

<div class="viewcode-block" id="Lattice.set_tag_classification">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.set_tag_classification">[docs]</a>
    <span class="k">def</span> <span class="nf">set_tag_classification</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define tag list classification.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_tags</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">102</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">106</span><span class="p">,</span> <span class="mi">107</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">108</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">111</span><span class="p">],</span> <span class="p">[</span><span class="mi">101</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span> <span class="mi">110</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_tags</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corner_tags</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1001</span><span class="p">,</span> <span class="mi">1002</span><span class="p">,</span> <span class="mi">1003</span><span class="p">,</span> <span class="mi">1004</span><span class="p">,</span> <span class="mi">1005</span><span class="p">,</span> <span class="mi">1006</span><span class="p">,</span> <span class="mi">1007</span><span class="p">]</span></div>


<div class="viewcode-block" id="Lattice.get_size_lattice">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_size_lattice">[docs]</a>
    <span class="k">def</span> <span class="nf">get_size_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the size of the lattice along each direction.</span>

<span class="sd">        Return:</span>
<span class="sd">        ---------</span>
<span class="sd">        size_lattice: list of float in dim 3</span>
<span class="sd">            Length of the lattice in each direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size_lattice</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">total_length</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">num_cells</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">][</span><span class="n">direction</span><span class="p">]</span>
            <span class="n">cell_size</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span><span class="p">][</span><span class="n">direction</span><span class="p">]</span>
            <span class="n">gradient_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">grad</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="k">for</span> <span class="n">grad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_dim</span><span class="p">[:</span><span class="n">num_cells</span><span class="p">]]</span>

            <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">gradient_factors</span><span class="p">:</span>
                <span class="n">total_length</span> <span class="o">+=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">cell_size</span>
            <span class="n">size_lattice</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_length</span>

        <span class="k">return</span> <span class="n">size_lattice</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">is_not_in_erased_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_cell_pos</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the cell is not in the erased region or inside the mesh.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        startCellPos: list of float</span>
<span class="sd">            (xStart, yStart, zStart) position of the cell to check.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        bool:</span>
<span class="sd">            True if the cell should be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eraser_blocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">delPart</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eraser_blocks</span><span class="p">:</span>
                <span class="n">inside_erased</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">delPart</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start_cell_pos</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">delPart</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">+</span> <span class="n">delPart</span><span class="p">[</span><span class="n">direction</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">inside_erased</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># cell removed</span>

<div class="viewcode-block" id="Lattice.is_point_in_mesh">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.is_point_in_mesh">[docs]</a>
    <span class="k">def</span> <span class="nf">is_point_in_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the point is inside the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_object</span><span class="o">.</span><span class="n">is_inside_mesh</span><span class="p">(</span><span class="n">point</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.is_cell_in_mesh">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.is_cell_in_mesh">[docs]</a>
    <span class="k">def</span> <span class="nf">is_cell_in_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the cell is in the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cellBoundaryPoint</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">corner_coordinates</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">cellBoundaryPoint</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_point_in_mesh</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_point_in_mesh</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">define_beam_node_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define index at each beam and node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">beamIndexed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nodeIndexed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nextBeamIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nextNodeIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Define already indexed beam and node</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">beamIndexed</span><span class="p">[</span><span class="n">beam</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextBeamIndex</span>
                    <span class="n">nextBeamIndex</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">nodeIndexed</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextNodeIndex</span>
                        <span class="n">nextNodeIndex</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Adding not indexed beam and node</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">beam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beamIndexed</span><span class="p">:</span>
                        <span class="n">beam</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">nextBeamIndex</span>
                        <span class="n">beamIndexed</span><span class="p">[</span><span class="n">beam</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextBeamIndex</span>
                        <span class="n">nextBeamIndex</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">beam</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">beamIndexed</span><span class="p">[</span><span class="n">beam</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeIndexed</span><span class="p">:</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">nextNodeIndex</span>
                            <span class="n">nodeIndexed</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextNodeIndex</span>
                            <span class="n">nextNodeIndex</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">nodeIndexed</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">define_cell_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define index at each cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cellIndexed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nextCellIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cellIndexed</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextCellIndex</span>
                <span class="n">nextCellIndex</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cell</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cellIndexed</span><span class="p">:</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">nextCellIndex</span>
                    <span class="n">cellIndexed</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextCellIndex</span>
                    <span class="n">nextCellIndex</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">define_cell_neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define neighbours for each cell in the lattice, with periodic boundaries if enabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_dict</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">pos_cell</span><span class="p">):</span> <span class="n">cell</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">}</span>

        <span class="n">neighbor_offsets</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">localBoundaryBox</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_periodicity</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">eraser_blocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_occupancy_matrix</span><span class="p">()</span>
            <span class="n">localBoundaryBox</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">neighbour_cells</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">boundaryBox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_relative_boundary_box</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="k">if</span> <span class="n">localBoundaryBox</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lattice_boundary_box</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">neighbor_offsets</span><span class="p">:</span>
                <span class="n">raw_pos</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">pos_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">pos_cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">pos_cell</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_periodicity</span><span class="p">:</span>
                    <span class="c1"># enable_periodicity X</span>
                    <span class="k">if</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">neighbor_x</span> <span class="o">=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">neighbor_x</span> <span class="o">=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">neighbor_x</span> <span class="o">=</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># enable_periodicity Y</span>
                    <span class="k">if</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">neighbor_y</span> <span class="o">=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                        <span class="n">neighbor_y</span> <span class="o">=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">neighbor_y</span> <span class="o">=</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># enable_periodicity Z</span>
                    <span class="k">if</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span>
                        <span class="n">neighbor_z</span> <span class="o">=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">5</span><span class="p">]:</span>
                        <span class="n">neighbor_z</span> <span class="o">=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">neighbor_z</span> <span class="o">=</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                    <span class="n">neighbor_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">neighbor_x</span><span class="p">,</span> <span class="n">neighbor_y</span><span class="p">,</span> <span class="n">neighbor_z</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">boundaryBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span>
                            <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="ow">and</span>
                            <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">5</span><span class="p">]):</span>
                        <span class="k">continue</span>
                    <span class="n">neighbor_pos</span> <span class="o">=</span> <span class="n">raw_pos</span>
                <span class="k">if</span> <span class="n">neighbor_pos</span> <span class="ow">in</span> <span class="n">cell_dict</span><span class="p">:</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">add_cell_neighbour</span><span class="p">(</span><span class="n">cell_dict</span><span class="p">[</span><span class="n">neighbor_pos</span><span class="p">])</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">get_list_angle_beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam</span><span class="p">:</span> <span class="s2">&quot;Beam&quot;</span><span class="p">,</span> <span class="n">pointbeams</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Beam&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate an angle between the considerate beam and beams contains in pointbeams</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        beam: Beam object</span>
<span class="sd">            Beam where an angle is computed on</span>
<span class="sd">        pointbeams: list of Beam object</span>
<span class="sd">            List of beam to calculate an angle with considered beam</span>

<span class="sd">        Return:</span>
<span class="sd">        ---------</span>
<span class="sd">        non_zero_anglebeam: list of an angle between considered beam and pointbeams beam list</span>
<span class="sd">        non_zero_radiusbeam: list of radii between a considered beam and pointbeams beam list</span>

<span class="sd">        Special case when pointbeams is an empty return max angle to minimize penalization zone</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">anglebeam</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">radiusBeam</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointbeams</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beampoint</span> <span class="ow">in</span> <span class="n">pointbeams</span><span class="p">:</span>
                <span class="n">radiusBeam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beampoint</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
                <span class="n">anglebeam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">get_angle_between_beams</span><span class="p">(</span><span class="n">beampoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_periodicity</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Not connected beam</span>
            <span class="n">radiusBeam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
            <span class="n">anglebeam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">179.9</span><span class="p">)</span>
        <span class="n">non_zero_anglebeam</span> <span class="o">=</span> <span class="p">[</span><span class="n">angle</span> <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">anglebeam</span> <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">]</span>
        <span class="n">non_zero_radiusbeam</span> <span class="o">=</span> <span class="p">[</span><span class="n">radius</span> <span class="k">for</span> <span class="n">angle</span><span class="p">,</span> <span class="n">radius</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">anglebeam</span><span class="p">,</span> <span class="n">radiusBeam</span><span class="p">)</span> <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">non_zero_anglebeam</span><span class="p">,</span> <span class="n">non_zero_radiusbeam</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">get_connected_beams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beamList</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Beam&quot;</span><span class="p">],</span> <span class="n">beam</span><span class="p">:</span> <span class="s2">&quot;Beam&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Beam&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Beam&quot;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all beams connected to the interest beam.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        beamList: list of Beam objects</span>
<span class="sd">            List of all beams in the lattice.</span>
<span class="sd">        beam: Beam</span>
<span class="sd">            Beam of interest.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">point1beams</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">point2beams</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">tag_checks</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="p">[(</span><span class="n">tags</span><span class="p">,</span> <span class="s1">&#39;corner&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">tags</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">corner_tags</span><span class="p">],</span> <span class="o">*</span><span class="p">[(</span><span class="n">tags</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">tags</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_tags</span><span class="p">],</span>
                      <span class="o">*</span><span class="p">[(</span><span class="n">tags</span><span class="p">,</span> <span class="s1">&#39;face&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">tags</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_tags</span><span class="p">]]</span>

        <span class="k">def</span> <span class="nf">is_periodic_connected</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">b_idx</span><span class="p">,</span> <span class="n">tags_range</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check if the point p is periodic connected to the beam index b_idx</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">p_tag_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p_tag_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tags_range</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">bp1_tag</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b_idx</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">tag</span> <span class="ow">or</span> <span class="p">[])</span>
            <span class="n">bp2_tag</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b_idx</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">tag</span> <span class="ow">or</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">bp1_tag</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">bp2_tag</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tags_range</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">p_local</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">local_tag</span><span class="p">)</span>
            <span class="n">bp1_local</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b_idx</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">local_tag</span> <span class="ow">or</span> <span class="p">[])</span>
            <span class="n">bp2_local</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b_idx</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">local_tag</span> <span class="ow">or</span> <span class="p">[])</span>

            <span class="k">if</span> <span class="n">tags_range</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">corner_tags</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">p_local</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tags_range</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bp1_local</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">bp2_local</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tags_range</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">p_local</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tags_range</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bp1_local</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">bp2_local</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tags_range</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">beamidx</span> <span class="ow">in</span> <span class="n">beamList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beamidx</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beamidx</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                <span class="n">point1beams</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">beamidx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beamidx</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beamidx</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                <span class="n">point2beams</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">beamidx</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_periodicity</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">tags_range</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tag_checks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_periodic_connected</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beamidx</span><span class="p">,</span> <span class="n">tags_range</span><span class="p">):</span>
                    <span class="n">point1beams</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">beamidx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_periodic_connected</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span> <span class="n">beamidx</span><span class="p">,</span> <span class="n">tags_range</span><span class="p">):</span>
                    <span class="n">point2beams</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">beamidx</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">point1beams</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">point2beams</span><span class="p">)</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">get_all_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates angles between beams in the lattice.</span>

<span class="sd">        Return:</span>
<span class="sd">        ---------</span>
<span class="sd">        angle:</span>
<span class="sd">            data structure =&gt; ((beam_index, Angle mininmum point 1, minRad1, Angle mininmum point 2, minRad2))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
        <span class="k">def</span> <span class="nf">find_min_angle</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">radii</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Find the Minimum angle between beams and radii connection to this particular beam</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">LValuesMax</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">LRadius</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">LAngle</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">radius</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">radii</span><span class="p">,</span> <span class="n">angles</span><span class="p">):</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">function_penalization_Lzone</span><span class="p">((</span><span class="n">radius</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="n">LValuesMax</span><span class="p">:</span>
                    <span class="n">LValuesMax</span> <span class="o">=</span> <span class="n">L</span>
                    <span class="n">LRadius</span> <span class="o">=</span> <span class="n">radius</span>
                    <span class="n">LAngle</span> <span class="o">=</span> <span class="n">angle</span>
            <span class="k">return</span> <span class="n">LAngle</span><span class="p">,</span> <span class="n">LRadius</span>

        <span class="c1"># Create the list of beam objects for each cell with neighbors cells</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">beamList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cellListNeighbours</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">neighbour_cells</span>
            <span class="n">cellListNeighbours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>  <span class="c1"># Include the cell itself</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">cellListNeighbours</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">neighbour</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">beam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beamList</span><span class="p">:</span>
                        <span class="n">beamList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
            <span class="n">angleList</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="c1"># Determine beams on nodes</span>
                <span class="n">point1beams</span><span class="p">,</span> <span class="n">point2beams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connected_beams</span><span class="p">(</span><span class="n">beamList</span><span class="p">,</span> <span class="n">beam</span><span class="p">)</span>
                <span class="c1"># Determine angles for all beams connected at the node</span>
                <span class="n">non_zero_anglebeam1</span><span class="p">,</span> <span class="n">non_zero_radiusbeam1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_list_angle_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">point1beams</span><span class="p">)</span>
                <span class="n">non_zero_anglebeam2</span><span class="p">,</span> <span class="n">non_zero_radiusbeam2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_list_angle_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">point2beams</span><span class="p">)</span>
                <span class="c1"># Find the lowest angle</span>
                <span class="n">LAngle1</span><span class="p">,</span> <span class="n">LRadius1</span> <span class="o">=</span> <span class="n">find_min_angle</span><span class="p">(</span><span class="n">non_zero_anglebeam1</span><span class="p">,</span> <span class="n">non_zero_radiusbeam1</span><span class="p">)</span>
                <span class="n">LAngle2</span><span class="p">,</span> <span class="n">LRadius2</span> <span class="o">=</span> <span class="n">find_min_angle</span><span class="p">(</span><span class="n">non_zero_anglebeam2</span><span class="p">,</span> <span class="n">non_zero_radiusbeam2</span><span class="p">)</span>
                <span class="n">angleList</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">LRadius1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">LAngle1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">LRadius2</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">LAngle2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">beam</span><span class="o">.</span><span class="n">set_angle</span><span class="p">(</span><span class="n">angleList</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">get_lattice_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes extremum values of coordinates in the lattice.</span>

<span class="sd">        Return:</span>
<span class="sd">        --------</span>
<span class="sd">        ExtrumumValues: tuple of floats (x_min, x_max, y_min, y_max, z_min, z_max)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No cells in the lattice.&quot;</span><span class="p">)</span>

        <span class="c1"># Flatten the list of nodes from all cells</span>
        <span class="n">all_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No nodes in the cells of the lattice.&quot;</span><span class="p">)</span>

        <span class="c1"># Extract coordinates</span>
        <span class="n">x_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">all_nodes</span><span class="p">]</span>
        <span class="n">y_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">all_nodes</span><span class="p">]</span>
        <span class="n">z_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">all_nodes</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_values</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_values</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">z_values</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">z_values</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_lattice_dimensions_dict</span><span class="p">()</span>

<div class="viewcode-block" id="Lattice.set_lattice_dimensions_dict">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.set_lattice_dimensions_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">set_lattice_dimensions_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set lattice dimensions in a dictionary format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice_dimension_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;x_min&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">,</span>
            <span class="s2">&quot;x_max&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">,</span>
            <span class="s2">&quot;y_min&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span>
            <span class="s2">&quot;y_max&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">,</span>
            <span class="s2">&quot;z_min&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">,</span>
            <span class="s2">&quot;z_max&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span>
        <span class="p">}</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">set_beam_node_mod</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies beam and node data to model lattice structures for simulation with rigidity penalization at node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">beamsToRemove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">beamToAdd</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="n">lengthMod</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">get_length_mod</span><span class="p">()</span>
                <span class="n">pointExt1</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">get_point_on_beam_at_distance</span><span class="p">(</span><span class="n">lengthMod</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pointExt1</span><span class="o">.</span><span class="n">node_mod</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">pointExt2</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">get_point_on_beam_at_distance</span><span class="p">(</span><span class="n">lengthMod</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">pointExt2</span><span class="o">.</span><span class="n">node_mod</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">b1</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">pointExt1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span><span class="p">)</span>
                <span class="n">b1</span><span class="o">.</span><span class="n">set_beam_mod</span><span class="p">()</span>
                <span class="n">b2</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">pointExt1</span><span class="p">,</span> <span class="n">pointExt2</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span><span class="p">)</span>
                <span class="n">b3</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">pointExt2</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span><span class="p">)</span>
                <span class="n">b3</span><span class="o">.</span><span class="n">set_beam_mod</span><span class="p">()</span>

                <span class="n">beamToAdd</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">))</span>

                <span class="n">beamsToRemove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">addingBeam</span> <span class="ow">in</span> <span class="n">beamToAdd</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">add_beam</span><span class="p">(</span><span class="n">addingBeam</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">beamsToRemove</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">remove_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>

        <span class="c1"># Update index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">define_beam_node_index</span><span class="p">()</span>

<div class="viewcode-block" id="Lattice.remove_cell">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.remove_cell">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a cell from the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ------------</span>
<span class="sd">        index: int</span>
<span class="sd">            index of the cell to remove</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Invalid cell index.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.find_minimum_beam_length">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.find_minimum_beam_length">[docs]</a>
    <span class="k">def</span> <span class="nf">find_minimum_beam_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find minimum beam length</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        minLength: float</span>
<span class="sd">            Length of the smallest beam in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">minLength</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">minLength</span> <span class="o">&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mf">0.0001</span> <span class="ow">and</span> <span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">minLength</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">length</span>
        <span class="k">return</span> <span class="n">minLength</span></div>


<div class="viewcode-block" id="Lattice.get_tag_list">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_tag_list">[docs]</a>
    <span class="k">def</span> <span class="nf">get_tag_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the tag for all unique points in the lattice.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        tagList: list of int</span>
<span class="sd">            List of all tags of each unique point in the lattice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tagList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen_nodes</span><span class="p">:</span>
                        <span class="n">tagList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
                        <span class="n">seen_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tagList</span></div>


<div class="viewcode-block" id="Lattice.get_tag_list_boundary">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_tag_list_boundary">[docs]</a>
    <span class="k">def</span> <span class="nf">get_tag_list_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the tag for boundary points in the lattice.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        tagList: list of int</span>
<span class="sd">            List of all tags of each point in lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boundary_box_lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lattice_boundary_box</span><span class="p">()</span>
        <span class="n">tagList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen_nodes</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">is_on_boundary</span><span class="p">(</span><span class="n">boundary_box_lattice</span><span class="p">):</span>
                        <span class="n">tagList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
                        <span class="n">seen_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tagList</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">apply_tag_all_point</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign a tag to all nodes in the lattice structure.</span>
<span class="sd">        Tags are assigned relative to either the global bounding box</span>
<span class="sd">        or a local (cell-relative) bounding box if erased parts are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">use_local_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eraser_blocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">use_local_box</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_occupancy_matrix</span><span class="p">()</span>

        <span class="n">global_box</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">use_local_box</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lattice_boundary_box</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">local_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_relative_boundary_box</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="k">if</span> <span class="n">use_local_box</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">tag</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tag_point</span><span class="p">(</span><span class="n">local_box</span> <span class="k">if</span> <span class="n">use_local_box</span> <span class="k">else</span> <span class="n">global_box</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span>

<div class="viewcode-block" id="Lattice.get_cell_occupancy_matrix">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_cell_occupancy_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">get_cell_occupancy_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a 3D boolean matrix indicating presence of a cell at each (i, j, k) position.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        occupancy_matrix: np.ndarray of shape (num_cells_x, num_cells_y, num_cells_z)</span>
<span class="sd">            True if a cell is present at the corresponding position, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pos_cell</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span></div>


<div class="viewcode-block" id="Lattice.get_cells_at_index">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_cells_at_index">[docs]</a>
    <span class="k">def</span> <span class="nf">get_cells_at_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all cells at a specific index along a specified axis.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        axis: str</span>
<span class="sd">            Axis to query (&#39;x&#39;, &#39;y&#39;, or &#39;z&#39;).</span>
<span class="sd">        index: int</span>
<span class="sd">            Index along the specified axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span><span class="p">[:,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axis must be &#39;x&#39;, &#39;y&#39;, or &#39;z&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.get_relative_boundary_box">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_relative_boundary_box">[docs]</a>
    <span class="k">def</span> <span class="nf">get_relative_boundary_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the relative boundary box of a cell in the lattice.</span>
<span class="sd">        It corresponds to the minimum and maximum dimension of the lattice for each axis with cell continuity.</span>
<span class="sd">        Useful for structures with erased parts or periodic boundaries.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        cell: Cell object</span>
<span class="sd">            The cell for which the boundary box is computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pos_cell</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span>
                <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span>
        <span class="p">):</span>
            <span class="n">arrayCell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cells_at_index</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="k">for</span> <span class="n">cellIn</span> <span class="ow">in</span> <span class="n">arrayCell</span><span class="p">:</span>
                <span class="n">cellInBoundaryBox</span> <span class="o">=</span> <span class="n">cellIn</span><span class="o">.</span><span class="n">boundary_box</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="n">cellInBoundaryBox</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="n">cellInBoundaryBox</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="n">cellInBoundaryBox</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_val</span><span class="p">:</span>
                    <span class="n">max_val</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_val</span><span class="p">)</span>
            <span class="n">bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bbox</span></div>


<div class="viewcode-block" id="Lattice.get_lattice_boundary_box">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_lattice_boundary_box">[docs]</a>
    <span class="k">def</span> <span class="nf">get_lattice_boundary_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the boundary box of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">]</span></div>


<div class="viewcode-block" id="Lattice.get_connected_node">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_connected_node">[docs]</a>
    <span class="k">def</span> <span class="nf">get_connected_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;Point&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Point&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all nodes connected to the input node with a beam</span>

<span class="sd">        Parameter:</span>
<span class="sd">        -----------</span>
<span class="sd">        node: point object</span>

<span class="sd">        Return:</span>
<span class="sd">        --------</span>
<span class="sd">        connectedNode: List of a point object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">connectedNode</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodeIndexRef</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">nodeIndexRef</span><span class="p">:</span>
                    <span class="n">connectedNode</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">nodeIndexRef</span><span class="p">:</span>
                    <span class="n">connectedNode</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">connectedNode</span></div>


<div class="viewcode-block" id="Lattice.find_boundary_beams">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.find_boundary_beams">[docs]</a>
    <span class="k">def</span> <span class="nf">find_boundary_beams</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Beam&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find boundary beams and change the type_beam of beam</span>

<span class="sd">        Return:</span>
<span class="sd">        -------</span>
<span class="sd">        boundaryBeams: List of a beam object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boundary_box_lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lattice_boundary_box</span><span class="p">()</span>
        <span class="n">boundaryBeams</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">is_on_boundary</span><span class="p">(</span><span class="n">boundary_box_lattice</span><span class="p">)</span> <span class="ow">or</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">is_on_boundary</span><span class="p">(</span><span class="n">boundary_box_lattice</span><span class="p">):</span>
                    <span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="n">boundaryBeams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">boundaryBeams</span></div>


<div class="viewcode-block" id="Lattice.find_boundary_nodes">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.find_boundary_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">find_boundary_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Point&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find boundary nodes</span>

<span class="sd">        Returns:</span>
<span class="sd">        ---------</span>
<span class="sd">        boundaryNodes: List of a point object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boundaryNodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="ow">or</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">):</span>
                        <span class="n">boundaryNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">boundaryNodes</span></div>


<div class="viewcode-block" id="Lattice.get_name_lattice">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_name_lattice">[docs]</a>
    <span class="k">def</span> <span class="nf">get_name_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the name_lattice of the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        ---------</span>
<span class="sd">        name_lattice: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nameList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;BCC&quot;</span><span class="p">,</span>  <span class="c1"># 0</span>
            <span class="s2">&quot;Octet&quot;</span><span class="p">,</span>  <span class="c1"># 1</span>
            <span class="s2">&quot;OctetExt&quot;</span><span class="p">,</span>  <span class="c1"># 2</span>
            <span class="s2">&quot;OctetInt&quot;</span><span class="p">,</span>  <span class="c1"># 3</span>
            <span class="s2">&quot;BCCZ&quot;</span><span class="p">,</span>  <span class="c1"># 4</span>
            <span class="s2">&quot;Cubic&quot;</span><span class="p">,</span>  <span class="c1"># 5</span>
            <span class="s2">&quot;OctahedronZ&quot;</span><span class="p">,</span>  <span class="c1"># 6</span>
            <span class="s2">&quot;OctahedronZcross&quot;</span><span class="p">,</span>  <span class="c1"># 7</span>
            <span class="s2">&quot;Kelvin&quot;</span><span class="p">,</span>  <span class="c1"># 8</span>
            <span class="s2">&quot;CubicV2&quot;</span><span class="p">,</span>  <span class="c1"># 9 (centered)</span>
            <span class="s2">&quot;CubicV3&quot;</span><span class="p">,</span>  <span class="c1"># 10</span>
            <span class="s2">&quot;CubicV4&quot;</span><span class="p">,</span>  <span class="c1"># 11</span>
            <span class="s2">&quot;NewlatticeUnknown&quot;</span><span class="p">,</span>  <span class="c1"># 12 GPT generated</span>
            <span class="s2">&quot;Diamond&quot;</span><span class="p">,</span>  <span class="c1"># 13</span>
            <span class="s2">&quot;Auxetic&quot;</span>  <span class="c1"># 14</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_lattice</span> <span class="o">=</span> <span class="n">nameList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_lattice</span> <span class="o">=</span> <span class="s2">&quot;Hybrid_&quot;</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">geom_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name_lattice</span> <span class="o">+=</span> <span class="n">nameList</span><span class="p">[</span><span class="n">geom_type</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_simulation_properties</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_lattice</span> <span class="o">+=</span> <span class="s2">&quot;_Mod&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_lattice</span></div>


<div class="viewcode-block" id="Lattice.check_hybrid_collision">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.check_hybrid_collision">[docs]</a>
    <span class="k">def</span> <span class="nf">check_hybrid_collision</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if beam in hybrid configuration is cut by a point in the geometry</span>
<span class="sd">        Change the beam configuration of collisionned beams</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cellPoints</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_list_points</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">cellPoints</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">isPointOnBeam</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                        <span class="n">typeBeamToRemove</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span>  <span class="c1"># Get beam to remove type_beam to apply in new separated beams</span>
                        <span class="n">beam1</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">typeBeamToRemove</span><span class="p">)</span>
                        <span class="n">beam2</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">typeBeamToRemove</span><span class="p">)</span>
                        <span class="n">cell</span><span class="o">.</span><span class="n">remove_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
                        <span class="n">cell</span><span class="o">.</span><span class="n">add_beam</span><span class="p">(</span><span class="n">beam1</span><span class="p">)</span>
                        <span class="n">cell</span><span class="o">.</span><span class="n">add_beam</span><span class="p">(</span><span class="n">beam2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.get_node_coordinates_data">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_node_coordinates_data">[docs]</a>
    <span class="k">def</span> <span class="nf">get_node_coordinates_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves position data for the lattice.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        posData: list of list of float</span>
<span class="sd">            List of node positions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">posData</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodeAlreadyAdded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeAlreadyAdded</span><span class="p">:</span>
                        <span class="n">posData</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">coordinates</span><span class="p">])</span>
                        <span class="n">nodeAlreadyAdded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">posData</span></div>


<div class="viewcode-block" id="Lattice.get_edge_index">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_edge_index">[docs]</a>
    <span class="k">def</span> <span class="nf">get_edge_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves edge index data for the lattice.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        edgeIndex: list of list of int</span>
<span class="sd">            List of edge index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edgeIndex</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">beamAlreadyAdded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beamAlreadyAdded</span><span class="p">:</span>
                    <span class="n">edgeIndex</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>
                    <span class="n">beamAlreadyAdded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">edgeIndex</span></div>


<div class="viewcode-block" id="Lattice.get_beam_type">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_beam_type">[docs]</a>
    <span class="k">def</span> <span class="nf">get_beam_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves beam type_beam data for the lattice.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        beamType: list of int</span>
<span class="sd">            List of beam types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">beamType</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">beamAlreadyAdded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beamAlreadyAdded</span><span class="p">:</span>
                    <span class="n">beamType</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">beamType</span></div>


<div class="viewcode-block" id="Lattice.get_all_beam_length">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_all_beam_length">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_beam_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves beam length data for the lattice.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        beamLength: list of float</span>
<span class="sd">            List of beam lengths</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">beamLength</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">beamAlreadyAdded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beamAlreadyAdded</span><span class="p">:</span>
                    <span class="n">beamLength</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">beam</span><span class="o">.</span><span class="n">length</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">beamLength</span></div>


<div class="viewcode-block" id="Lattice.change_beam_radius_data_hybrid_lattice">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.change_beam_radius_data_hybrid_lattice">[docs]</a>
    <span class="k">def</span> <span class="nf">change_beam_radius_data_hybrid_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hybridRadiusData</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change radii data for hybrid lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ------------</span>
<span class="sd">        hybridRadiusData: list of float</span>
<span class="sd">            List of radii data for hybrid lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hybridRadiusData</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid hybrid radii data.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">beam_mod</span><span class="p">:</span>
                    <span class="n">beam</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">hybridRadiusData</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span><span class="p">]</span> <span class="o">*</span> <span class="n">beam</span><span class="o">.</span><span class="n">penalization_coefficient</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">beam</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">hybridRadiusData</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span><span class="p">]</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">delete_duplicated_beams</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete duplicated beams in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">beamList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beamList</span><span class="p">:</span>
                    <span class="n">beamList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">remove_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>

<div class="viewcode-block" id="Lattice.get_relative_density_constraint">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_relative_density_constraint">[docs]</a>
    <span class="k">def</span> <span class="nf">get_relative_density_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relativeDensityMax</span><span class="p">,</span> <span class="n">geomScheme</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get relative density of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">relativeDensity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_relative_density</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Relative density: &quot;</span><span class="p">,</span> <span class="n">relativeDensity</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">relativeDensity</span> <span class="o">-</span> <span class="n">relativeDensityMax</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Relative density maximum: &quot;</span><span class="p">,</span> <span class="n">relativeDensityMax</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Relative density error: &quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">error</span></div>


<div class="viewcode-block" id="Lattice.get_relative_density">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_relative_density">[docs]</a>
    <span class="k">def</span> <span class="nf">get_relative_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom_scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get mean relative density of all cells in lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        meanRelDens: float</span>
<span class="sd">            Mean relative density of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cellRelDens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging_model_relative_density</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cellRelDens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">get_relative_density_kriging</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kriging_model_relative_density</span><span class="p">,</span> <span class="n">geom_scheme</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cellRelDens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">getRelativeDensityCell</span><span class="p">())</span>
        <span class="n">meanRelDens</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">cellRelDens</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">meanRelDens</span></div>


<div class="viewcode-block" id="Lattice.define_relative_density_function">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.define_relative_density_function">[docs]</a>
    <span class="k">def</span> <span class="nf">define_relative_density_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define relative density function</span>
<span class="sd">        Possible to define a more complex function with dependency on hybrid cells</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        degree: int</span>
<span class="sd">            Degree of the polynomial function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relative_density_poly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fictiveCell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_radius</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_mat</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">uncertainty_node</span><span class="p">)</span>
            <span class="n">domainRadius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idxRad</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">)):</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">))</span>
                <span class="n">relativeDensity</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">domainIdx</span> <span class="ow">in</span> <span class="n">domainRadius</span><span class="p">:</span>
                    <span class="n">radius</span><span class="p">[</span><span class="n">idxRad</span><span class="p">]</span> <span class="o">=</span> <span class="n">domainIdx</span>
                    <span class="n">fictiveCell</span><span class="o">.</span><span class="n">change_beam_radius</span><span class="p">([</span><span class="n">radius</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_radius</span><span class="p">)</span>
                    <span class="n">relativeDensity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fictiveCell</span><span class="o">.</span><span class="n">relative_density</span><span class="p">())</span>
                <span class="n">poly_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">domainRadius</span><span class="p">,</span> <span class="n">relativeDensity</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">poly_coeffs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relative_density_poly</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relative_density_poly_deriv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">deriv</span><span class="p">())</span></div>


<div class="viewcode-block" id="Lattice.get_relative_density_gradient">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_relative_density_gradient">[docs]</a>
    <span class="k">def</span> <span class="nf">get_relative_density_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get relative density gradient of the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        grad: list of float</span>
<span class="sd">            Gradient of relative density</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relative_density_poly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">define_relative_density_function</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">radii</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relative_density_poly</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid radii data.&quot;</span><span class="p">)</span>

        <span class="n">grad</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">grad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">get_relative_density_gradient</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">grad</span></div>


<div class="viewcode-block" id="Lattice.get_relative_density_gradient_kriging">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_relative_density_gradient_kriging">[docs]</a>
    <span class="k">def</span> <span class="nf">get_relative_density_gradient_kriging</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom_scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get relative density gradient of the lattice using kriging model</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        grad: list of float</span>
<span class="sd">            Gradient of relative density</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">numberOfCells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geom_scheme</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">geom_scheme</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">geom_scheme</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">gradient3Geom</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_relative_density_gradient_kriging</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kriging_model_relative_density</span><span class="p">,</span>
                                                                       <span class="n">geom_scheme</span><span class="p">)</span> <span class="o">/</span> <span class="n">numberOfCells</span>
            <span class="n">grad</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">gradient3Geom</span><span class="p">[</span><span class="n">geom_scheme</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">grad</span></div>


<div class="viewcode-block" id="Lattice.get_radius_continuity_difference">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_radius_continuity_difference">[docs]</a>
    <span class="k">def</span> <span class="nf">get_radius_continuity_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the difference in radii between connected beams in the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        delta: float</span>
<span class="sd">            Minimum difference in radii between connected cells</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">radiusContinuityDifference</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">radiusCell</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">radii</span>
            <span class="k">for</span> <span class="n">neighbours</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">neighbour_cells</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">rad</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">radiusCell</span><span class="p">)):</span>
                    <span class="n">radiusContinuityDifference</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">radiusCell</span><span class="p">[</span><span class="n">rad</span><span class="p">]</span> <span class="o">-</span> <span class="n">neighbours</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="n">rad</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">radiusContinuityDifference</span></div>


<div class="viewcode-block" id="Lattice.get_radius_continuity_jacobian">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_radius_continuity_jacobian">[docs]</a>
    <span class="k">def</span> <span class="nf">get_radius_continuity_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Jacobian of the radii continuity constraint.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Jacobian matrix of shape (num_constraints, num_radii)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">constraint_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">radiusCell</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">radii</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">neighbour_cells</span><span class="p">:</span>
                <span class="n">radiusNeighbour</span> <span class="o">=</span> <span class="n">neighbour</span><span class="o">.</span><span class="n">radii</span>
                <span class="k">for</span> <span class="n">rad</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">radiusCell</span><span class="p">)):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">radiusCell</span><span class="p">)</span> <span class="o">+</span> <span class="n">rad</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">neighbour</span><span class="o">.</span><span class="n">index</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">radiusCell</span><span class="p">)</span> <span class="o">+</span> <span class="n">rad</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="n">radiusCell</span><span class="p">[</span><span class="n">rad</span><span class="p">]</span> <span class="o">-</span> <span class="n">radiusNeighbour</span><span class="p">[</span><span class="n">rad</span><span class="p">]</span>

                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constraint_index</span><span class="p">)</span>
                    <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">diff</span><span class="p">)</span>

                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constraint_index</span><span class="p">)</span>
                    <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">diff</span><span class="p">)</span>

                    <span class="n">constraint_index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">jacobian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">constraint_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_parameters_optimization</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="n">jacobian</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="n">jacobian</span></div>


<div class="viewcode-block" id="Lattice.change_beam_radius_depending_type">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.change_beam_radius_depending_type">[docs]</a>
    <span class="k">def</span> <span class="nf">change_beam_radius_depending_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeToChange</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">newRadius</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change radii of beam for specific type_beam</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        typeToChange: int</span>
<span class="sd">            Type of beam to change</span>
<span class="sd">        newRadius: float</span>
<span class="sd">            New radii of beam</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span> <span class="o">==</span> <span class="n">typeToChange</span><span class="p">:</span>
                    <span class="n">beam</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">newRadius</span></div>


<div class="viewcode-block" id="Lattice.get_number_beams">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_number_beams">[docs]</a>
    <span class="k">def</span> <span class="nf">get_number_beams</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get number of beams in the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        numBeams: int</span>
<span class="sd">            Number of beams in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numBeams</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">numBeams</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numBeams</span></div>


<div class="viewcode-block" id="Lattice.get_number_nodes">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_number_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">get_number_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get number of nodes in the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        numNodes: int</span>
<span class="sd">            Number of nodes in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numNodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nodeIndexList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeIndexList</span><span class="p">:</span>
                        <span class="n">nodeIndexList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                        <span class="n">numNodes</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">numNodes</span></div>


<div class="viewcode-block" id="Lattice.apply_boundary_conditions_surface">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.apply_boundary_conditions_surface">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_boundary_conditions_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceNames</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">valueDisplacement</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                                         <span class="n">DOF</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply boundary conditions to the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surfaceNames: list[str]</span>
<span class="sd">            List of surfaces to apply boundary conditions (e.g., [&quot;Xmin&quot;, &quot;Xmax&quot;, &quot;Ymin&quot;])</span>
<span class="sd">        valueDisplacement: list of float</span>
<span class="sd">            Displacement value to apply to the boundary conditions</span>
<span class="sd">        DOF: list of int</span>
<span class="sd">            Degree of freedom to fix (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_constraints_nodes</span><span class="p">(</span><span class="n">surfaceNames</span><span class="p">,</span> <span class="n">valueDisplacement</span><span class="p">,</span> <span class="n">DOF</span><span class="p">,</span> <span class="s2">&quot;Displacement&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.apply_constraints_nodes">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.apply_constraints_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_constraints_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceNames</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">DOF</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                                   <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Displacement&quot;</span><span class="p">,</span> <span class="n">surfaceNamePoint</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply boundary conditions to the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surfaceNames: list[str]</span>
<span class="sd">            List of surfaces to apply constraint (e.g., [&quot;Xmin&quot;, &quot;Xmax&quot;, &quot;Ymin&quot;])</span>
<span class="sd">        value: list of float</span>
<span class="sd">            Values to apply to the constraint</span>
<span class="sd">        DOF: list of int</span>
<span class="sd">            Degree of freedom to apply constraint (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz)</span>
<span class="sd">        type_beam: str</span>
<span class="sd">            Type of constraint (Displacement, Force)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">surfaceNamePoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pointSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_point_on_lattice_surface</span><span class="p">(</span><span class="n">surfaceNames</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pointSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_point_on_lattice_surface_complex</span><span class="p">(</span><span class="n">surfaceNames</span><span class="p">,</span> <span class="n">surfaceNamePoint</span><span class="p">)</span>

        <span class="n">indexBoundaryList</span> <span class="o">=</span> <span class="p">{</span><span class="n">point</span><span class="o">.</span><span class="n">index_boundary</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">pointSet</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span> <span class="ow">in</span> <span class="n">indexBoundaryList</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">DOFi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DOF</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;Displacement&quot;</span><span class="p">:</span>
                                <span class="n">node</span><span class="o">.</span><span class="n">displacement_vector</span><span class="p">[</span><span class="n">DOFi</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                                <span class="n">node</span><span class="o">.</span><span class="n">fix_DOF</span><span class="p">([</span><span class="n">DOFi</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;Force&quot;</span><span class="p">:</span>
                                <span class="n">node</span><span class="o">.</span><span class="n">applied_force</span><span class="p">[</span><span class="n">DOFi</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span></div>


<div class="viewcode-block" id="Lattice.find_point_on_lattice_surface">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.find_point_on_lattice_surface">[docs]</a>
    <span class="k">def</span> <span class="nf">find_point_on_lattice_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceNames</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="s2">&quot;Point&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find points on the surface of the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surfaceNames: list[str]</span>
<span class="sd">            List of surfaces to find points on (e.g., [&quot;Xmin&quot;, &quot;Xmax&quot;, &quot;Ymin&quot;])</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        pointSet: set of Point objects</span>
<span class="sd">            Set of points found on the specified surfaces</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_surfaces</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xmin&quot;</span><span class="p">,</span> <span class="s2">&quot;Xmax&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymin&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymax&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmin&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmax&quot;</span><span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">surface</span> <span class="ow">in</span> <span class="n">valid_surfaces</span> <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="n">surfaceNames</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid surface name_lattice(s).&quot;</span><span class="p">)</span>

        <span class="n">cellLists</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell_on_surface</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span> <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="n">surfaceNames</span><span class="p">]</span>
        <span class="n">cellList</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cellLists</span><span class="p">)</span>  <span class="c1"># Union of all cell indices from given surfaces</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">cellList</span><span class="p">,</span> <span class="n">default</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid cell index, some cells do not exist.&quot;</span><span class="p">)</span>

        <span class="n">pointSet</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">cellList</span><span class="p">:</span>
                <span class="n">cellPointSets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">get_point_on_surface</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span> <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="n">surfaceNames</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cellPointSets</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pointSet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">pointSet</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cellPointSets</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pointSet</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cellPointSets</span><span class="p">))</span>
        <span class="n">pointSet</span> <span class="o">=</span> <span class="n">pointSet</span> <span class="k">if</span> <span class="n">pointSet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pointSet</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No points found on the specified surfaces.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pointSet</span></div>


<div class="viewcode-block" id="Lattice.find_point_on_lattice_surface_complex">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.find_point_on_lattice_surface_complex">[docs]</a>
    <span class="k">def</span> <span class="nf">find_point_on_lattice_surface_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceNamesCell</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">surfaceNamePoint</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> \
            <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="s2">&quot;Point&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find points on the surface of the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surfaceNames: list[str]</span>
<span class="sd">            List of surfaces to find points on (e.g., [&quot;Xmin&quot;, &quot;Xmax&quot;, &quot;Ymin&quot;])</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        pointSet: set of Point objects</span>
<span class="sd">            Set of points found on the specified surfaces</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_surfaces</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xmin&quot;</span><span class="p">,</span> <span class="s2">&quot;Xmax&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymin&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymax&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmin&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmax&quot;</span><span class="p">,</span> <span class="s2">&quot;Xmid&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymid&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmid&quot;</span><span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">surface</span> <span class="ow">in</span> <span class="n">valid_surfaces</span> <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="n">surfaceNamesCell</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid surface name_lattice(s).&quot;</span><span class="p">)</span>

        <span class="n">cellLists</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell_on_surface</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span> <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="n">surfaceNamesCell</span><span class="p">]</span>
        <span class="n">cellList</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cellLists</span><span class="p">)</span>  <span class="c1"># Union of all cell indices from given surfaces</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">cellList</span><span class="p">,</span> <span class="n">default</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid cell index, some cells do not exist.&quot;</span><span class="p">)</span>

        <span class="n">pointSet</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">cellList</span><span class="p">:</span>
                <span class="n">cellPointSets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">get_point_on_surface</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span> <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="n">surfaceNamePoint</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cellPointSets</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pointSet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">pointSet</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cellPointSets</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pointSet</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cellPointSets</span><span class="p">))</span>
        <span class="n">pointSet</span> <span class="o">=</span> <span class="n">pointSet</span> <span class="k">if</span> <span class="n">pointSet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pointSet</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No points found on the specified surfaces.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pointSet</span></div>


<div class="viewcode-block" id="Lattice.apply_boundary_conditions_node">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.apply_boundary_conditions_node">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_boundary_conditions_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeList</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">valueDisplacement</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                                      <span class="n">DOF</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply boundary conditions to the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        nodeList: list of int</span>
<span class="sd">            List of node index to apply boundary conditions</span>
<span class="sd">        valueDisplacement: float</span>
<span class="sd">            Displacement value to apply to the boundary conditions</span>
<span class="sd">        DOF: int</span>
<span class="sd">            Degree of freedom to fix (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO: Check if used</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">nodeList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid node index, node do not exist.&quot;</span><span class="p">)</span>

        <span class="n">indexBoundaryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">node</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node index out of range.&quot;</span><span class="p">)</span>
            <span class="n">indexBoundaryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">indexBoundaryList</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">DOFi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">valueDisplacement</span><span class="p">,</span> <span class="n">DOF</span><span class="p">):</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">displacement_vector</span><span class="p">[</span><span class="n">DOFi</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">fix_DOF</span><span class="p">([</span><span class="n">DOFi</span><span class="p">])</span></div>


<div class="viewcode-block" id="Lattice.apply_force_on_surface">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.apply_force_on_surface">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_force_on_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceName</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">valueForce</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">DOF</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply force to the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surface: str</span>
<span class="sd">            Surface to apply force (Xmin, Xmax, Ymin, Ymax, Zmin, Zmax)</span>
<span class="sd">        valueForce: list of float</span>
<span class="sd">            Force value to apply to the boundary conditions</span>
<span class="sd">        DOF: list of int</span>
<span class="sd">            List of degree of freedom to fix (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_constraints_nodes</span><span class="p">(</span><span class="n">surfaceName</span><span class="p">,</span> <span class="n">valueForce</span><span class="p">,</span> <span class="n">DOF</span><span class="p">,</span> <span class="s2">&quot;Force&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.fix_DOF_on_surface">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.fix_DOF_on_surface">[docs]</a>
    <span class="k">def</span> <span class="nf">fix_DOF_on_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceName</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">dofFixed</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix degree of freedom on the surface of the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        cellList: list of int</span>
<span class="sd">            List of cell index to apply boundary conditions</span>
<span class="sd">        surface: str</span>
<span class="sd">            Surface to apply boundary conditions (Xmin, Xmax, Ymin, Ymax, Zmin, Zmax)</span>
<span class="sd">        dofFixed: list of int</span>
<span class="sd">            List of degree of freedom to fix (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_constraints_nodes</span><span class="p">(</span><span class="n">surfaceName</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dofFixed</span><span class="p">],</span> <span class="n">dofFixed</span><span class="p">,</span> <span class="s2">&quot;Displacement&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.fix_DOF_on_node">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.fix_DOF_on_node">[docs]</a>
    <span class="k">def</span> <span class="nf">fix_DOF_on_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeList</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">dofFixed</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix degree of freedom on the surface of the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        nodeList: list of int</span>
<span class="sd">            List of node index to apply boundary conditions</span>
<span class="sd">        dofFixed: list of int</span>
<span class="sd">            List of degree of freedom to fix (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">nodeList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid node index, node do not exist.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">node</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node index out of range.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">nodeList</span><span class="p">:</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">fix_DOF</span><span class="p">(</span><span class="n">dofFixed</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.set_displacement_with_vector">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.set_displacement_with_vector">[docs]</a>
    <span class="k">def</span> <span class="nf">set_displacement_with_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">displacementMatrix</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set displacement on the lattice with vector</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        displacementMatrix: list of float of dim n_nodes*n_dofperNode</span>
<span class="sd">            Displacement matrix to apply to the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">nodeInOrder</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_node_order_to_simulate</span><span class="p">()</span>
            <span class="n">idxNode</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodeInOrder</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">displacement_vector</span> <span class="o">=</span> <span class="n">displacementMatrix</span><span class="p">[</span><span class="n">idxNode</span><span class="p">]</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">fix_DOF</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)])</span>
                    <span class="n">idxNode</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Lattice.get_global_displacement">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_global_displacement">[docs]</a>
    <span class="k">def</span> <span class="nf">get_global_displacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">withFixed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">OnlyImposed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">printLevel</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get global displacement of the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        withFixed: bool</span>
<span class="sd">            If True, return displacement of all nodes, else return only free degree of freedom</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        globalDisplacement: dict</span>
<span class="sd">            Dictionary of global displacement with index_boundary as key and displacement vector as value</span>
<span class="sd">        global_displacement_index: list of int</span>
<span class="sd">            List of index_boundary of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">globalDisplacement</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">globalDisplacementIndex</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">processed_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed_nodes</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">fixed_DOF</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">OnlyImposed</span><span class="p">:</span>
                                <span class="n">globalDisplacement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">displacement_vector</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                <span class="n">globalDisplacementIndex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">fixed_DOF</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">applied_force</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">globalDisplacement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">withFixed</span> <span class="ow">or</span> <span class="n">OnlyImposed</span><span class="p">:</span>
                                <span class="n">globalDisplacement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">displacement_vector</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                <span class="n">globalDisplacementIndex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span><span class="p">)</span>

                        <span class="n">processed_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">OnlyImposed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_displacement_index</span> <span class="o">=</span> <span class="n">globalDisplacementIndex</span>
        <span class="k">if</span> <span class="n">printLevel</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;globalDisplacement: &quot;</span><span class="p">,</span> <span class="n">globalDisplacement</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;global_displacement_index: &quot;</span><span class="p">,</span> <span class="n">globalDisplacementIndex</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">globalDisplacement</span><span class="p">,</span> <span class="n">globalDisplacementIndex</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">define_node_index_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define boundary tag for all boundary nodes and calculate the total number of boundary nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">IndexCounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nodeAlreadyIndexed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">localTag</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tag_point</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">boundary_box</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">set_local_tag</span><span class="p">(</span><span class="n">localTag</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">localTag</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeAlreadyIndexed</span><span class="p">:</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span> <span class="o">=</span> <span class="n">nodeAlreadyIndexed</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">nodeAlreadyIndexed</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">IndexCounter</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span> <span class="o">=</span> <span class="n">IndexCounter</span>
                            <span class="n">IndexCounter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_index_boundary</span> <span class="o">=</span> <span class="n">IndexCounter</span> <span class="o">-</span> <span class="mi">1</span>

<div class="viewcode-block" id="Lattice.set_point_local_tag">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.set_point_local_tag">[docs]</a>
    <span class="k">def</span> <span class="nf">set_point_local_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set local tag for all points in the lattice based on their position within the cell boundary box.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">localTag</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tag_point</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">boundary_box</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">set_local_tag</span><span class="p">(</span><span class="n">localTag</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.get_global_reaction_force">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_global_reaction_force">[docs]</a>
    <span class="k">def</span> <span class="nf">get_global_reaction_force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appliedForceAdded</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get local reaction force of the lattice and sum if identical TagIndex</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        globalReactionForce: dict</span>
<span class="sd">            Dictionary of global reaction force with index_boundary as key and reaction force vector as value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">globalReactionForce</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_index_boundary</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">nodeIndexProcessed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeIndexProcessed</span><span class="p">:</span>
                        <span class="n">globalReactionForce</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">globalReactionForce</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span><span class="p">],</span> <span class="n">node</span><span class="o">.</span><span class="n">reaction_force_vector</span><span class="p">)</span>
                        <span class="p">]</span>
                        <span class="k">if</span> <span class="n">appliedForceAdded</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">applied_force</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">globalReactionForce</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">applied_force</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">nodeIndexProcessed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">globalReactionForce</span></div>


<div class="viewcode-block" id="Lattice.getGlobalReactionForceWithoutFixedDOF">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getGlobalReactionForceWithoutFixedDOF">[docs]</a>
    <span class="k">def</span> <span class="nf">getGlobalReactionForceWithoutFixedDOF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">globalReactionForce</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">rightHandSide</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get global reaction force of free degree of freedom</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        globalReactionForce: dict</span>
<span class="sd">            Dictionary of global reaction force with index_boundary as key and reaction force vector as value</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        globalReactionForceWithoutFixedDOF: np.ndarray</span>
<span class="sd">            Array of global reaction force without fixed degree of freedom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">globalReactionForceWithoutFixedDOF</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">processed_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed_nodes</span><span class="p">:</span>
                        <span class="c1"># Append reaction force components where fixed_DOF is 0</span>
                        <span class="n">RFToAdd</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">applied_force</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">rightHandSide</span><span class="p">:</span>
                                <span class="n">RFToAdd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">node</span><span class="o">.</span><span class="n">applied_force</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                <span class="c1"># Add a sign minus because right-hand side already with a sign minus see (b = -b)</span>
                            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">fixed_DOF</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">RFToAdd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">globalReactionForce</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">globalReactionForceWithoutFixedDOF</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">RFToAdd</span><span class="p">)</span>
                        <span class="c1"># globalReactionForceWithoutFixedDOF.append([</span>
                        <span class="c1">#     v1 for v1, v2 in zip(globalReactionForce[node.index_boundary], node.fixed_DOF)</span>
                        <span class="c1">#     if v2 == 0])</span>
                        <span class="c1"># print(globalReactionForceWithoutFixedDOF[-1])</span>
                        <span class="c1"># Mark this node as processed</span>
                        <span class="n">processed_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">globalReactionForceWithoutFixedDOF</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.set_free_DOF">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.set_free_DOF">[docs]</a>
    <span class="k">def</span> <span class="nf">set_free_DOF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get total number of degrees of freedom in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_DOF</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">processed_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed_nodes</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">free_DOF</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="n">fixed_DOF</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">processed_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.set_global_free_DOF_index">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.set_global_free_DOF_index">[docs]</a>
    <span class="k">def</span> <span class="nf">set_global_free_DOF_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set global free degree of freedom index for all nodes in boundary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">processed_nodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed_nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">fixed_DOF</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">node</span><span class="o">.</span><span class="n">global_free_DOF_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span>
                                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">processed_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">global_free_DOF_index</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">global_free_DOF_index</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">processed_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">index_boundary</span><span class="p">]</span></div>


<div class="viewcode-block" id="Lattice.initialize_reaction_force">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.initialize_reaction_force">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_reaction_force</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize reaction force of all nodes to 0 on each DOF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">initialize_reaction_force</span><span class="p">()</span></div>


<div class="viewcode-block" id="Lattice.initialize_displacement">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.initialize_displacement">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_displacement</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize displacement of all nodes to zero on each DOF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">initialize_displacement</span><span class="p">()</span></div>


<div class="viewcode-block" id="Lattice.build_coupling_operator_cells">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.build_coupling_operator_cells">[docs]</a>
    <span class="k">def</span> <span class="nf">build_coupling_operator_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build coupling operator for each cell in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">build_coupling_operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_DOF</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.build_LU_schur_complement">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.build_LU_schur_complement">[docs]</a>
    <span class="k">def</span> <span class="nf">build_LU_schur_complement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictSchurComplement</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">splu</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build LU decomposition of the Schur complement matrix for the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        schurComplementMatrix: coo_matrix</span>
<span class="sd">            Schur complement matrix of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO : Voir quoi faire avec ça</span>
        <span class="kn">from</span> <span class="nn">ConjugateGradientMethod.Utils_Schur</span> <span class="kn">import</span> <span class="n">loadSchurComplement</span><span class="p">,</span> <span class="n">getSref_nearest</span>

        <span class="k">if</span> <span class="n">dictSchurComplement</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nameFileSchur</span> <span class="o">=</span> <span class="s2">&quot;ConjugateGradientMethod/schurComplement/Hybrid_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;.npz&quot;</span>
            <span class="n">dictSchurComplement</span> <span class="o">=</span> <span class="n">loadSchurComplement</span><span class="p">(</span><span class="n">nameFileSchur</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">build_coupling_operator_cells</span><span class="p">()</span>
        <span class="n">globalSchurComplement</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">free_DOF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_DOF</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">schurComplementMatrix</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">(</span><span class="n">getSref_nearest</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">radii</span><span class="p">,</span> <span class="n">SchurDict</span><span class="o">=</span><span class="n">dictSchurComplement</span><span class="p">,</span>
                                                               <span class="n">printing</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="n">globalSchurComplement</span> <span class="o">+=</span> <span class="n">cell</span><span class="o">.</span><span class="n">build_preconditioner</span><span class="p">(</span><span class="n">schurComplementMatrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">globalSchurComplement</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attention : There are some rows with all zeros in the Schur complement matrix.&quot;</span><span class="p">)</span>
        <span class="n">cond_number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">globalSchurComplement</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Condition number of the Schur complement matrix: &quot;</span><span class="p">,</span> <span class="n">cond_number</span><span class="p">)</span>

        <span class="c1"># Factorize preconditioner</span>
        <span class="n">LUSchurComplement</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">inverseSchurComplement</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">cond_number</span> <span class="o">&gt;</span> <span class="mf">1e15</span><span class="p">:</span>
            <span class="n">inverseSchurComplement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">globalSchurComplement</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
            <span class="c1"># inverseSchurComplement = None</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using pseudo-inverse of the Schur complement matrix.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">globalSchurComplement</span> <span class="o">=</span> <span class="n">globalSchurComplement</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
            <span class="n">LUSchurComplement</span> <span class="o">=</span> <span class="n">splu</span><span class="p">(</span><span class="n">globalSchurComplement</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using LU decomposition of the Schur complement matrix.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LUSchurComplement</span><span class="p">,</span> <span class="n">inverseSchurComplement</span></div>


<div class="viewcode-block" id="Lattice.get_cell_on_surface">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_cell_on_surface">[docs]</a>
    <span class="k">def</span> <span class="nf">get_cell_on_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a cell list on the surface of the lattice.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surface: str</span>
<span class="sd">            Surface to get points (&quot;Xmin&quot;, &quot;Xmax&quot;, &quot;Ymin&quot;, &quot;Ymax&quot;, &quot;Zmin&quot;, &quot;Zmax&quot;, &quot;Xmid&quot;, &quot;Ymid&quot;, &quot;Zmid&quot;)</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        cellTagList: list of cell index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_surfaces</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Xmin&quot;</span><span class="p">,</span> <span class="s2">&quot;Xmax&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymin&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymax&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmin&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmax&quot;</span><span class="p">,</span> <span class="s2">&quot;Xmid&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymid&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmid&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">surface</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_surfaces</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid surface name_lattice.&quot;</span><span class="p">)</span>

        <span class="n">mid_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Xmid&quot;</span><span class="p">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">),</span>
            <span class="s2">&quot;Ymid&quot;</span><span class="p">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">),</span>
            <span class="s2">&quot;Zmid&quot;</span><span class="p">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_min</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="n">surface_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Xmin&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">),</span>
            <span class="s2">&quot;Xmax&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">),</span>
            <span class="s2">&quot;Ymin&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">),</span>
            <span class="s2">&quot;Ymax&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">),</span>
            <span class="s2">&quot;Zmin&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">),</span>
            <span class="s2">&quot;Zmax&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">),</span>
            <span class="s2">&quot;Xmid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">mid_dict</span><span class="p">[</span><span class="s2">&quot;Xmid&quot;</span><span class="p">]),</span>
            <span class="s2">&quot;Ymid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">mid_dict</span><span class="p">[</span><span class="s2">&quot;Ymid&quot;</span><span class="p">]),</span>
            <span class="s2">&quot;Zmid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="n">mid_dict</span><span class="p">[</span><span class="s2">&quot;Zmid&quot;</span><span class="p">])</span>
        <span class="p">}</span>

        <span class="n">axis</span><span class="p">,</span> <span class="n">valueSurface</span> <span class="o">=</span> <span class="n">surface_dict</span><span class="p">[</span><span class="n">surface</span><span class="p">]</span>

        <span class="n">cellTagList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">listPointOnSurface</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_point_on_surface</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">listPointOnSurface</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="n">valueSurface</span><span class="p">:</span>
                    <span class="n">cellTagList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">cellTagList</span></div>


<div class="viewcode-block" id="Lattice.get_radius_temp">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_radius_temp">[docs]</a>
    <span class="k">def</span> <span class="nf">get_radius_temp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ################### TEMPORARY FUNCTION ###################</span>
<span class="sd">        Get the radii of the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        radii: float</span>
<span class="sd">            radii of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span></div>


<div class="viewcode-block" id="Lattice.unnormalize_r">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.unnormalize_r">[docs]</a>
    <span class="k">def</span> <span class="nf">unnormalize_r</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r_norm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Denormalize optimization parameters</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        r_norm: float</span>
<span class="sd">            Normalized optimization parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO : To delete</span>
        <span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span>
        <span class="k">return</span> <span class="n">r_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">r_max</span> <span class="o">-</span> <span class="n">r_min</span><span class="p">)</span> <span class="o">*</span> <span class="n">r_norm</span>  <span class="c1"># Dé-normalisation</span></div>


<div class="viewcode-block" id="Lattice.set_optimization_parameters">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.set_optimization_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">set_optimization_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optimizationParameters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">geomScheme</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set optimization parameters for the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        optimizationParameters: list of float</span>
<span class="sd">            List of optimization parameters</span>
<span class="sd">        geomScheme: list of bool</span>
<span class="sd">            List of N boolean values indicating the scheme of geometry to optimize</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">optimizationParameters</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_parameters_optimization</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid number of optimization parameters.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geomScheme</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">numberOfParametersPerCell</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numberOfParametersPerCell</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">startIdx</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="o">*</span> <span class="n">numberOfParametersPerCell</span>
            <span class="n">endIdx</span> <span class="o">=</span> <span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">numberOfParametersPerCell</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">optimizationParameters</span><span class="p">[</span><span class="n">startIdx</span><span class="p">:</span><span class="n">endIdx</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">radii</span><span class="p">):</span>
                <span class="c1"># Reconstruct the full radii vector based on geomScheme</span>
                <span class="n">full_radius</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># index for radii (optimization vector)</span>
                <span class="k">for</span> <span class="n">keep</span><span class="p">,</span> <span class="n">old</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">radii</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
                        <span class="n">full_radius</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">radius</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">full_radius</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="n">full_radius</span>

            <span class="n">cell</span><span class="o">.</span><span class="n">change_beam_radius</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_radius</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.calculate_objective">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.calculate_objective">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeObjective</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate objective function for the lattice optimization</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeObjective: str</span>
<span class="sd">            Type of objective function to calculate (Compliance...)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        objectiveValue: float</span>
<span class="sd">            Objective function value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">typeObjective</span> <span class="o">==</span> <span class="s2">&quot;Compliance&quot;</span><span class="p">:</span>
            <span class="n">reactionForce</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_global_reaction_force</span><span class="p">(</span><span class="n">appliedForceAdded</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">reaction_force_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">reactionForce</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_global_displacement</span><span class="p">(</span><span class="n">OnlyImposed</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">objective</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">reaction_force_array</span><span class="p">,</span> <span class="n">displacement</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reaction force: &quot;</span><span class="p">,</span> <span class="n">reaction_force_array</span><span class="p">[</span><span class="n">displacement</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Displacement: &quot;</span><span class="p">,</span> <span class="n">displacement</span><span class="p">[</span><span class="n">displacement</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Compliance: &quot;</span><span class="p">,</span> <span class="n">objective</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">typeObjective</span> <span class="o">==</span> <span class="s2">&quot;Displacement&quot;</span><span class="p">:</span>
            <span class="n">setNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_point_on_lattice_surface</span><span class="p">(</span><span class="n">surfaceNames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">objectif_data</span><span class="p">[</span><span class="s2">&quot;surface&quot;</span><span class="p">])</span>
            <span class="n">displacements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">setNode</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objectif_data</span><span class="p">[</span><span class="s2">&quot;DOF&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dof</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid degree of freedom index.&quot;</span><span class="p">)</span>
                    <span class="n">displacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">displacement_vector</span><span class="p">[</span><span class="n">dof</span><span class="p">])</span>
            <span class="n">displacements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">displacements</span><span class="p">)</span>
            <span class="n">objective</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">displacements</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">displacements</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">typeObjective</span> <span class="o">==</span> <span class="s2">&quot;Stiffness&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">objective</span></div>


<div class="viewcode-block" id="Lattice.get_number_parameters_optimization">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_number_parameters_optimization">[docs]</a>
    <span class="k">def</span> <span class="nf">get_number_parameters_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geomScheme</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get number of parameters for optimization</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        numParameters: int</span>
<span class="sd">            Number of parameters for optimization</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numParameters</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">geomScheme</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">numParameters</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">radii</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numParameters</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numParameters</span></div>


<div class="viewcode-block" id="Lattice.apply_reaction_force_on_node_list">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.apply_reaction_force_on_node_list">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_reaction_force_on_node_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionForce</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">nodeCoordinatesList</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply reaction force on node list</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        reactionForce: list of float</span>
<span class="sd">            Reaction force to apply</span>
<span class="sd">        nodeCoordinatesList: list of float</span>
<span class="sd">            Coordinates of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodeCoordinatesArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodeCoordinatesList</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">nodeCoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nodeCoordinatesArray</span> <span class="o">==</span> <span class="n">nodeCoord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">match</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">set_reaction_force</span><span class="p">(</span><span class="n">reactionForce</span><span class="p">[</span><span class="n">index</span><span class="p">])</span></div>


<div class="viewcode-block" id="Lattice.apply_displacement_on_node_list">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.apply_displacement_on_node_list">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_displacement_on_node_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">displacement</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">nodeCoordinatesList</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply displacement on node list</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        displacement: list of float</span>
<span class="sd">            Displacement to apply</span>
<span class="sd">        nodeCoordinatesList: list of float</span>
<span class="sd">            Coordinates of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodeCoordinatesArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodeCoordinatesList</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">nodeCoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nodeCoordinatesArray</span> <span class="o">==</span> <span class="n">nodeCoord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">match</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">displacement_vector</span> <span class="o">=</span> <span class="n">displacement</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">fix_DOF</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)])</span></div>


<div class="viewcode-block" id="Lattice.expand_schur_to_full_basis">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.expand_schur_to_full_basis">[docs]</a>
    <span class="k">def</span> <span class="nf">expand_schur_to_full_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SchurReduced</span><span class="p">,</span> <span class="n">nodeInOrder</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand the reduced Schur complement matrix into the full 156-DOF boundary space.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        SchurReduced : np.ndarray</span>
<span class="sd">            The Schur complement matrix computed only for the active boundary nodes.</span>
<span class="sd">        nodeInOrder : dict</span>
<span class="sd">            Dictionary with node tags as keys and corresponding node objects as values.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        SchurFull : np.ndarray</span>
<span class="sd">            The expanded Schur complement matrix in the full 156-DOF boundary space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO : Check if used</span>
        <span class="n">num_total_boundary_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodeInOrder</span><span class="p">)</span>  <span class="c1"># Nombre total de nœuds frontière</span>
        <span class="n">total_dofs</span> <span class="o">=</span> <span class="n">num_total_boundary_nodes</span> <span class="o">*</span> <span class="mi">6</span>  <span class="c1"># Chaque nœud a 6 DOFs</span>
        <span class="n">SchurFull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">total_dofs</span><span class="p">,</span> <span class="n">total_dofs</span><span class="p">))</span>  <span class="c1"># Matrice complète initialisée à zéro</span>

        <span class="c1"># Construire un mapping entre les indices de SchurReduced et les indices globaux</span>
        <span class="n">boundary_dof_map</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Associe index local -&gt; index global dans SchurFull</span>
        <span class="n">dof_counter</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Compteur pour attribuer des indices locaux à la matrice réduite</span>

        <span class="k">for</span> <span class="n">node_idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodeInOrder</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Le nœud est utilisé</span>
                <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>  <span class="c1"># Chaque nœud a 6 DOFs</span>
                    <span class="n">boundary_dof_map</span><span class="p">[</span><span class="n">dof_counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_idx</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">dof</span>
                    <span class="n">dof_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Remplir SchurFull en utilisant les indices mappés</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">SchurReduced</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">global_i</span> <span class="o">=</span> <span class="n">boundary_dof_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># Trouver l&#39;index global correspondant</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">SchurReduced</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">global_j</span> <span class="o">=</span> <span class="n">boundary_dof_map</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">SchurFull</span><span class="p">[</span><span class="n">global_i</span><span class="p">,</span> <span class="n">global_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">SchurReduced</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">SchurFull</span></div>


<div class="viewcode-block" id="Lattice.print_statistics_lattice">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.print_statistics_lattice">[docs]</a>
    <span class="k">def</span> <span class="nf">print_statistics_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print statistics about the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lattice name: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_name_lattice</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of cells: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of beams: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_beams</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of nodes: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Relative density: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_relative_density</span><span class="p">())</span>
        <span class="n">radMax</span><span class="p">,</span> <span class="n">radMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_beam_radius_min_max</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;radii max: &quot;</span><span class="p">,</span> <span class="n">radMax</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;radii min: &quot;</span><span class="p">,</span> <span class="n">radMin</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lattice dimensions: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_size_lattice</span><span class="p">())</span></div>


<div class="viewcode-block" id="Lattice.get_beam_radius_min_max">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.get_beam_radius_min_max">[docs]</a>
    <span class="k">def</span> <span class="nf">get_beam_radius_min_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the maximum and minimum radii of the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        radMax: float</span>
<span class="sd">            Maximum radii of the lattice</span>
<span class="sd">        radMin: float</span>
<span class="sd">            Minimum radii of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">radMin</span> <span class="o">=</span> <span class="mi">1000000</span>
        <span class="n">radMax</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">beam</span><span class="o">.</span><span class="n">beam_mod</span><span class="p">:</span>
                    <span class="n">radMin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">radMin</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
                    <span class="n">radMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">radMax</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">radMax</span><span class="p">,</span> <span class="n">radMin</span></div>


<div class="viewcode-block" id="Lattice.add_mesh_object">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.add_mesh_object">[docs]</a>
    <span class="k">def</span> <span class="nf">add_mesh_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meshObject</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a mesh object to the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        mesh_object: MeshObject</span>
<span class="sd">            Mesh object to add to the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO : Changer gestion des mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_object</span> <span class="o">=</span> <span class="n">meshObject</span></div>


<div class="viewcode-block" id="Lattice.cut_beams_at_mesh_intersection">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.cut_beams_at_mesh_intersection">[docs]</a>
    <span class="k">def</span> <span class="nf">cut_beams_at_mesh_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cut beams at the intersection with the mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A mesh object must be assigned to the lattice before cutting beams.&quot;</span><span class="p">)</span>

        <span class="n">new_beams</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">beams_to_remove</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">beam</span><span class="o">.</span><span class="n">beam_mod</span><span class="p">:</span>
                    <span class="n">p1_inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_object</span><span class="o">.</span><span class="n">is_inside_mesh</span><span class="p">([</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
                    <span class="n">p2_inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_object</span><span class="o">.</span><span class="n">is_inside_mesh</span><span class="p">([</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">p1_inside</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">p2_inside</span><span class="p">:</span>
                        <span class="c1"># The Beam is outside the mesh, remove it</span>
                        <span class="n">beams_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">p1_inside</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">p2_inside</span><span class="p">:</span>
                        <span class="c1"># The Beam intersects the mesh, cut it</span>
                        <span class="n">intersection_point</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">find_intersection_with_mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_object</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">intersection_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">new_point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">intersection_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intersection_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">intersection_point</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

                            <span class="k">if</span> <span class="ow">not</span> <span class="n">p1_inside</span><span class="p">:</span>
                                <span class="n">new_beam</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">new_point</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">new_beam</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">new_point</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span><span class="p">)</span>

                            <span class="n">new_beams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_beam</span><span class="p">)</span>
                            <span class="n">beams_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cutting is only available for non modified lattice.&quot;</span><span class="p">)</span>
            <span class="c1"># Apply changes</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">beams_to_remove</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">remove_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">new_beams</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">add_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>

            <span class="n">new_beams</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">beams_to_remove</span> <span class="o">=</span> <span class="p">[]</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">apply_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symmetry_plane</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">reference_point</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply symmetry to the lattice structure based on a reference point.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        symmetry_plane : str</span>
<span class="sd">            The plane of symmetry, can be &quot;XY&quot;, &quot;XZ&quot;, &quot;YZ&quot; (default symmetries),</span>
<span class="sd">            or &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; for symmetry about a specific coordinate.</span>
<span class="sd">        reference_point : tuple (x_ref, y_ref, z_ref), optional</span>
<span class="sd">            The reference point for the symmetry. Defaults to (0,0,0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">symmetry_plane</span> <span class="o">=</span> <span class="n">symmetry_plane</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">symmetry_plane</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="s2">&quot;XZ&quot;</span><span class="p">,</span> <span class="s2">&quot;YZ&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid symmetry plane. Choose from &#39;XY&#39;, &#39;XZ&#39;, &#39;YZ&#39;, &#39;X&#39;, &#39;Y&#39;, or &#39;Z&#39;.&quot;</span><span class="p">)</span>

        <span class="n">x_ref</span><span class="p">,</span> <span class="n">y_ref</span><span class="p">,</span> <span class="n">z_ref</span> <span class="o">=</span> <span class="n">reference_point</span>
        <span class="n">new_cells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">node_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">new_pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">pos_cell</span><span class="p">)</span>
            <span class="n">new_start_pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">coordinate_cell</span><span class="p">)</span>
            <span class="n">mirrored_beams</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="n">new_point1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
                <span class="n">new_point2</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

                <span class="c1"># Apply symmetry transformation based on the selected plane</span>
                <span class="k">if</span> <span class="n">symmetry_plane</span> <span class="o">==</span> <span class="s2">&quot;XY&quot;</span><span class="p">:</span>
                    <span class="n">new_point1</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_ref</span> <span class="o">-</span> <span class="n">new_point1</span><span class="o">.</span><span class="n">z</span>
                    <span class="n">new_point2</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_ref</span> <span class="o">-</span> <span class="n">new_point2</span><span class="o">.</span><span class="n">z</span>
                    <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_ref</span> <span class="o">-</span> <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symmetry_plane</span> <span class="o">==</span> <span class="s2">&quot;XZ&quot;</span><span class="p">:</span>
                    <span class="n">new_point1</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_ref</span> <span class="o">-</span> <span class="n">new_point1</span><span class="o">.</span><span class="n">y</span>
                    <span class="n">new_point2</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_ref</span> <span class="o">-</span> <span class="n">new_point2</span><span class="o">.</span><span class="n">y</span>
                    <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_ref</span> <span class="o">-</span> <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symmetry_plane</span> <span class="o">==</span> <span class="s2">&quot;YZ&quot;</span><span class="p">:</span>
                    <span class="n">new_point1</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ref</span> <span class="o">-</span> <span class="n">new_point1</span><span class="o">.</span><span class="n">x</span>
                    <span class="n">new_point2</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ref</span> <span class="o">-</span> <span class="n">new_point2</span><span class="o">.</span><span class="n">x</span>
                    <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ref</span> <span class="o">-</span> <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symmetry_plane</span> <span class="o">==</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
                    <span class="n">new_point1</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ref</span> <span class="o">-</span> <span class="n">new_point1</span><span class="o">.</span><span class="n">x</span>
                    <span class="n">new_point2</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ref</span> <span class="o">-</span> <span class="n">new_point2</span><span class="o">.</span><span class="n">x</span>
                    <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ref</span> <span class="o">-</span> <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symmetry_plane</span> <span class="o">==</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span>
                    <span class="n">new_point1</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_ref</span> <span class="o">-</span> <span class="n">new_point1</span><span class="o">.</span><span class="n">y</span>
                    <span class="n">new_point2</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_ref</span> <span class="o">-</span> <span class="n">new_point2</span><span class="o">.</span><span class="n">y</span>
                    <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_ref</span> <span class="o">-</span> <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symmetry_plane</span> <span class="o">==</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
                    <span class="n">new_point1</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_ref</span> <span class="o">-</span> <span class="n">new_point1</span><span class="o">.</span><span class="n">z</span>
                    <span class="n">new_point2</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_ref</span> <span class="o">-</span> <span class="n">new_point2</span><span class="o">.</span><span class="n">z</span>
                    <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_ref</span> <span class="o">-</span> <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                <span class="c1"># Ensure uniqueness of nodes</span>
                <span class="k">if</span> <span class="n">new_point1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_map</span><span class="p">:</span>
                    <span class="n">node_map</span><span class="p">[</span><span class="n">new_point1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_point1</span>
                <span class="k">if</span> <span class="n">new_point2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_map</span><span class="p">:</span>
                    <span class="n">node_map</span><span class="p">[</span><span class="n">new_point2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_point2</span>

                <span class="n">mirrored_beams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Beam</span><span class="p">(</span><span class="n">node_map</span><span class="p">[</span><span class="n">new_point1</span><span class="p">],</span> <span class="n">node_map</span><span class="p">[</span><span class="n">new_point2</span><span class="p">],</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span><span class="p">))</span>

            <span class="c1"># Create a new mirrored cell</span>
            <span class="n">new_cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">new_pos</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">cell_size</span><span class="p">,</span> <span class="n">new_start_pos</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">geom_types</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">radii</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">grad_radius</span><span class="p">,</span>
                            <span class="n">cell</span><span class="o">.</span><span class="n">grad_dim</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">grad_mat</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">uncertainty_node</span><span class="p">)</span>

            <span class="n">new_cell</span><span class="o">.</span><span class="n">beams</span> <span class="o">=</span> <span class="n">mirrored_beams</span>
            <span class="n">new_cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_cells</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_lattice_dimensions</span><span class="p">()</span>  <span class="c1"># Recalculate the lattice boundaries</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">load_relative_density_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="s2">&quot;Lattice/Saved_Lattice/RelativeDensityKrigingModel.pkl&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the relative density model from a file</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        model_path: str</span>
<span class="sd">            Path to the model file</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        model: Kriging</span>
<span class="sd">            The loaded model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">model_path</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model file not found: </span><span class="si">{</span><span class="n">model_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gpr</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kriging_model_relative_density</span> <span class="o">=</span> <span class="n">gpr</span>

<div class="viewcode-block" id="Lattice.delete_beams_under_radius_threshold">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.delete_beams_under_radius_threshold">[docs]</a>
    <span class="k">def</span> <span class="nf">delete_beams_under_radius_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete beams with radii under a certain threshold</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        threshold: float</span>
<span class="sd">            Threshold value for beam radii</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">beamsToRemove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">:</span>
                    <span class="n">beamsToRemove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">beamsToRemove</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">remove_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.delete_beams_with_geom_scheme">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.delete_beams_with_geom_scheme">[docs]</a>
    <span class="k">def</span> <span class="nf">delete_beams_with_geom_scheme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geomScheme</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete beams based on the geometry scheme.</span>
<span class="sd">        If geomScheme[i] is False, the beam of type_beam i will be removed.</span>
<span class="sd">        Usefull for hybrid lattices geometry.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        geomScheme: list of bool</span>
<span class="sd">            List of N boolean values indicating the scheme of geometry to optimize</span>
<span class="sd">            If geomScheme[i] is False, the beam of type_beam i will be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">beamsToRemove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">geomScheme</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">type_beam</span><span class="p">]:</span>
                    <span class="n">beamsToRemove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">beamsToRemove</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">remove_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.set_objective_data">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.set_objective_data">[docs]</a>
    <span class="k">def</span> <span class="nf">set_objective_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objectifData</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add objective data to the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        objectif_data: dict</span>
<span class="sd">            Dictionary containing objective data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO : Voir la gestion des objectifs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objectif_data</span> <span class="o">=</span> <span class="n">objectifData</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">generate_mesh_lattice_Gmsh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutMeshAtBoundary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">meshSize</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">runGmshApp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span>
    <span class="kc">False</span><span class="p">,</span> <span class="n">saveMesh</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">nameMesh</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Lattice&quot;</span><span class="p">,</span> <span class="n">saveSTL</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a mesh representation of the lattice structure using GMSH.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        cutMeshAtBoundary: bool</span>
<span class="sd">            If True, cut the mesh at the bounding box of the lattice.</span>
<span class="sd">        meshSize: float</span>
<span class="sd">            Size of the mesh elements.</span>
<span class="sd">        runGmshApp: bool</span>
<span class="sd">            If True, run the GMSH application to visualize the mesh.</span>
<span class="sd">        saveMesh: bool</span>
<span class="sd">            If True, save the mesh to a file.</span>
<span class="sd">        nameMesh: str</span>
<span class="sd">            Name of the mesh file to save.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_simulation_properties</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mesh generation is not available for the current simulation method.&quot;</span><span class="p">)</span>

        <span class="n">gmsh</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
        <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nameMesh</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Dimension of the mesh</span>

        <span class="n">all_tags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
                <span class="n">direction</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_tags</span><span class="p">:</span>
                    <span class="n">beamMesh</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCylinder</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="o">*</span><span class="n">direction</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">beam</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                    <span class="n">all_tags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beamMesh</span><span class="p">)</span>

        <span class="c1"># Merge all beams into a single entity</span>
        <span class="n">beam_entities</span> <span class="o">=</span> <span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">all_tags</span><span class="p">]</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">fragment</span><span class="p">(</span><span class="n">beam_entities</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">if</span> <span class="n">cutMeshAtBoundary</span><span class="p">:</span>
            <span class="c1"># Bounding box definition</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span>
            <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span> <span class="o">-</span> <span class="n">z0</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addBox</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">)</span>
            <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">box</span><span class="p">)],</span> <span class="n">removeObject</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

        <span class="c1"># Define mesh size</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">getEntities</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">setSize</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">meshSize</span><span class="p">)</span>
        <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

        <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">runGmshApp</span><span class="p">:</span>
            <span class="n">gmsh</span><span class="o">.</span><span class="n">fltk</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

        <span class="n">saving_path</span> <span class="o">=</span> <span class="s2">&quot;Mesh/&quot;</span>
        <span class="k">if</span> <span class="n">saveMesh</span><span class="p">:</span>
            <span class="n">gmsh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">saving_path</span> <span class="o">+</span> <span class="n">nameMesh</span> <span class="o">+</span> <span class="s2">&quot;.msh&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh saved as &quot;</span><span class="p">,</span> <span class="n">nameMesh</span> <span class="o">+</span> <span class="s2">&quot;.msh&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">saveSTL</span><span class="p">:</span>
            <span class="n">gmsh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">saving_path</span> <span class="o">+</span> <span class="n">nameMesh</span> <span class="o">+</span> <span class="s2">&quot;.stl&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh saved as &quot;</span><span class="p">,</span> <span class="n">nameMesh</span> <span class="o">+</span> <span class="s2">&quot;.stl&quot;</span><span class="p">)</span>

        <span class="n">gmsh</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

<div class="viewcode-block" id="Lattice.are_cells_identical">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.are_cells_identical">[docs]</a>
    <span class="k">def</span> <span class="nf">are_cells_identical</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if all cells in the list are identical based on their attributes and beams.</span>
<span class="sd">        Print the result.</span>
<span class="sd">        Possible upgrade could be to use a more sophisticated comparison method (Only beam length is checked for now).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">Fore</span><span class="o">.</span><span class="n">GREEN</span> <span class="o">+</span> <span class="s2">&quot;Only one or no cell: considered identical.&quot;</span> <span class="o">+</span> <span class="n">Style</span><span class="o">.</span><span class="n">RESET_ALL</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">reference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">attrs_to_check</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;geom_types&quot;</span><span class="p">,</span>
            <span class="s2">&quot;radii&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cell_size&quot;</span><span class="p">,</span>
            <span class="s2">&quot;grad_radius&quot;</span><span class="p">,</span>
            <span class="s2">&quot;grad_dim&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs_to_check</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">attr</span><span class="p">)):</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="n">Fore</span><span class="o">.</span><span class="n">RED</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;Difference found in attribute &#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&#39; between cell 0 and cell </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">Style</span><span class="o">.</span><span class="n">RESET_ALL</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">beams</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">Fore</span><span class="o">.</span><span class="n">RED</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;Different number of beams between cell 0 and cell </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">Style</span><span class="o">.</span><span class="n">RESET_ALL</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">beams</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">b1</span><span class="o">.</span><span class="n">is_identical_to</span><span class="p">(</span><span class="n">b2</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">Fore</span><span class="o">.</span><span class="n">RED</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;Difference found in beam </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> between cell 0 and cell </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">Style</span><span class="o">.</span><span class="n">RESET_ALL</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">Fore</span><span class="o">.</span><span class="n">GREEN</span> <span class="o">+</span> <span class="s2">&quot;All cells are identical.&quot;</span> <span class="o">+</span> <span class="n">Style</span><span class="o">.</span><span class="n">RESET_ALL</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Thomas Cadart.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>