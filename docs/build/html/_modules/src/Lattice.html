

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>src.Lattice &mdash; pyLattice 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pyLattice
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyLattice</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">src.Lattice</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for src.Lattice</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Lattice.py</span>

<span class="sd">Generate lattice structures with various parameters and properties.</span>

<span class="sd">This module provides the Lattice class, which allows for the creation and manipulation of lattice structures,</span>
<span class="sd">including the definition of cell dimensions, material properties, and gradient settings. It also supports simulation methods and uncertainty handling.</span>

<span class="sd">Created in 2023 by Cadart Thomas, University of technology Belfort Montb√©liard.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">statistics</span> <span class="kn">import</span> <span class="n">mean</span>

<span class="kn">import</span> <span class="nn">joblib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">splu</span>
<span class="kn">import</span> <span class="nn">gmsh</span>

<span class="kn">from</span> <span class="nn">Cell</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">Timing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">Utils</span> <span class="kn">import</span> <span class="n">_validate_inputs</span>
<span class="kn">from</span> <span class="nn">gradientProperties</span> <span class="kn">import</span> <span class="n">getGradSettings</span><span class="p">,</span> <span class="n">gradMaterialSetting</span><span class="p">,</span> <span class="n">grad_settings_constant</span>

<span class="n">timing</span> <span class="o">=</span> <span class="n">Timing</span><span class="p">()</span>


<div class="viewcode-block" id="Lattice">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice">[docs]</a>
<span class="k">class</span> <span class="nc">Lattice</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate lattice structures with a lot of different parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_size_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cell_size_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cell_size_z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">num_cells_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_cells_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_cells_z</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">geom_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">radii</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">material_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                 <span class="n">grad_radius_property</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">grad_dim_property</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">grad_mat_property</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">uncertainty_node</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">enable_periodicity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">eraser_blocks</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">meshObject</span><span class="p">:</span> <span class="s2">&quot;mesh&quot;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">printing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">symmetry_lattice</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">enable_simulation_properties</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor general for the Lattice class.</span>

<span class="sd">        Parameter:</span>
<span class="sd">        -----------</span>
<span class="sd">        cell_size_x: float</span>
<span class="sd">        cell_size_y: float</span>
<span class="sd">        cell_size_z: float</span>
<span class="sd">            Dimension in each direction of the intial cell in the structure</span>

<span class="sd">        num_cells_x: integer</span>
<span class="sd">        num_cells_y: integer</span>
<span class="sd">        num_cells_z: integer</span>
<span class="sd">            Number of cells in each direction in the structure</span>

<span class="sd">        geom_types: list of integer</span>
<span class="sd">            Geometry type the cell</span>
<span class="sd">                (-2 =&gt; Method random cell, -1 =&gt; Full random)</span>
<span class="sd">                (&gt;= 0 =&gt; Type of cell in the Geometry_lattice.py file)</span>
<span class="sd">        radii: list of float</span>
<span class="sd">            Initial radius geometry</span>
<span class="sd">        material_name: string</span>
<span class="sd">            Name of the default material in the lattice structure (&#39;Ti-6Al-4V&#39;, &#39;VeroClear&#39;...)</span>
<span class="sd">            Possible to add more material in the Material.py file</span>

<span class="sd">        Gradient properties</span>
<span class="sd">        gradRadiusProperty: array of data as [GradDimRule,GradDimDirection,GradDimParameters]</span>
<span class="sd">            radii gradient on the lattice structure</span>
<span class="sd">        gradDimProperty: array of data as [GradRadRule,GradRadDirection,GradRadParameters]</span>
<span class="sd">            Cell dimension gradient on the lattice structure</span>
<span class="sd">                GradRule =&gt; constant, linear, parabolic, sinusoide, exponential</span>
<span class="sd">                GradDirection =&gt; [bool,bool,bool] set integer to True to active gradient in direction [X,Y,Z] False inactive</span>
<span class="sd">                GradParameters =&gt; [float, float, float] variable in the gradient rule for each direction [X,Y,Z]</span>
<span class="sd">        gradMatProperty: array of data as [Multimat,GradMaterialDirection]</span>
<span class="sd">            Material gradient on the lattice structure</span>
<span class="sd">                Multimat =&gt; Type of multimaterial (0: inactive / 1: multimat by layer / -1: Full random)</span>

<span class="sd">        uncertaintyNode: integer (0: off / 1: on)</span>
<span class="sd">            Control if adding uncertainties on node position</span>
<span class="sd">        hybridLatticeData: array of 3 integer [RadiusOfGeometry1,RadiusOfGeometry2,RadiusOfGeometry3]</span>
<span class="sd">            Data of radius of each geometry on the hybrid lattice</span>
<span class="sd">        periodicity: boolean (0: off / 1: on)</span>
<span class="sd">            Applying periodicity on the outer box of the lattice structure to calculate penalization method</span>
<span class="sd">        erasedParts: list of float in dim 6</span>
<span class="sd">            (xStart, yStart, zStart, xDim, yDim, zDim) of the erased region</span>
<span class="sd">        meshObject: meshObject</span>
<span class="sd">            Mesh object to check if the lattice structure is inside the mesh</span>
<span class="sd">        printing: boolean</span>
<span class="sd">            Print information about the lattice structure</span>
<span class="sd">        symmetry_lattice: dictionary {&quot;sym_plane&quot;: string, &quot;sym_point&quot;: tuple}</span>
<span class="sd">            Data to apply symmetry on the lattice structure</span>
<span class="sd">        simulationProperties: boolean</span>
<span class="sd">            If True, the lattice will generate properties necessary for simulation and optimization</span>
<span class="sd">            And joint beam penalization method will be applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_validate_inputs</span><span class="p">(</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="n">cell_size_y</span><span class="p">,</span> <span class="n">cell_size_z</span><span class="p">,</span> <span class="n">num_cells_x</span><span class="p">,</span> <span class="n">num_cells_y</span><span class="p">,</span> <span class="n">num_cells_z</span><span class="p">,</span>
                         <span class="n">geom_types</span><span class="p">,</span> <span class="n">radii</span><span class="p">,</span> <span class="n">material_name</span><span class="p">,</span> <span class="n">grad_radius_property</span><span class="p">,</span> <span class="n">grad_dim_property</span><span class="p">,</span> <span class="n">grad_mat_property</span><span class="p">,</span>
                            <span class="n">uncertainty_node</span><span class="p">,</span> <span class="n">enable_periodicity</span><span class="p">,</span> <span class="n">eraser_blocks</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yMin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yMax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xMax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xMin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zMax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zMin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latticeDimensionsDict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dictSchurComplement</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objectifData</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span> <span class="o">=</span> <span class="n">cell_size_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span> <span class="o">=</span> <span class="n">cell_size_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span> <span class="o">=</span> <span class="n">cell_size_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span> <span class="o">=</span> <span class="n">num_cells_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span> <span class="o">=</span> <span class="n">num_cells_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span> <span class="o">=</span> <span class="n">num_cells_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span> <span class="o">=</span> <span class="n">geom_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radii</span> <span class="o">=</span> <span class="n">radii</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material_name</span> <span class="o">=</span> <span class="n">material_name</span>
        <span class="k">if</span> <span class="n">grad_radius_property</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gradRadius</span> <span class="o">=</span> <span class="n">getGradSettings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">,</span> <span class="n">grad_radius_property</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gradRadius</span> <span class="o">=</span> <span class="n">grad_settings_constant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grad_dim_property</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gradDim</span> <span class="o">=</span> <span class="n">getGradSettings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">,</span> <span class="n">grad_dim_property</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gradDim</span> <span class="o">=</span> <span class="n">grad_settings_constant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grad_mat_property</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gradMat</span> <span class="o">=</span> <span class="n">gradMaterialSetting</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">,</span> <span class="n">grad_mat_property</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gradMat</span> <span class="o">=</span> <span class="n">grad_settings_constant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">,</span> <span class="n">material_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enable_simulation_properties</span> <span class="o">=</span> <span class="n">enable_simulation_properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sizeX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizeY</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizeZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSizeLattice</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uncertaintyNode</span> <span class="o">=</span> <span class="n">uncertainty_node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">periodicity</span> <span class="o">=</span> <span class="n">enable_periodicity</span>  <span class="c1"># Warning not working for graded structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">erasedParts</span> <span class="o">=</span> <span class="n">eraser_blocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshObject</span> <span class="o">=</span> <span class="n">meshObject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">printing</span> <span class="o">=</span> <span class="n">printing</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Simulation necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freeDOF</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Free DOF gradient conjugate gradient method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxIndexBoundary</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">globalDisplacementIndex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialValueObjective</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialRelativeDensityConstraint</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialContinuityConstraint</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relativeDensityPoly</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relativeDensityPolyDeriv</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nDOFperNode</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Number of DOF per node (3 translation + 3 rotation)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameterOptimization</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">krigingModelRelativeDensity</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">penalizationCoefficient</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.5</span>  <span class="c1"># Fixed with previous optimization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshLattice</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Generate global structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generateLattice</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">symmetry_lattice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">applySymmetry</span><span class="p">(</span><span class="n">symmetry_lattice</span><span class="p">[</span><span class="s2">&quot;sym_plane&quot;</span><span class="p">],</span> <span class="n">symmetry_lattice</span><span class="p">[</span><span class="s2">&quot;sym_point&quot;</span><span class="p">])</span>

        <span class="c1"># Generate important data for the lattice structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getMinMaxValues</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defineBeamNodeIndex</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defineCellIndex</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defineCellNeighbours</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setPointLocalTag</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">applyTagToAllPoint</span><span class="p">()</span>

        <span class="c1"># Simulation necessaries</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_simulation_properties</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getAllAngles</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setBeamNodeMod</span><span class="p">()</span>

            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Material name must be defined for simulation properties.&quot;</span>
            <span class="c1"># Define global indexation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defineNodeIndexBoundary</span><span class="p">()</span>
            <span class="c1"># Optimization necessary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loadRelativeDensityModel</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">printStatistics</span><span class="p">()</span>

<div class="viewcode-block" id="Lattice.simpleLattice">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.simpleLattice">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">simpleLattice</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cell_size_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cell_size_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cell_size_z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="n">num_cells_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_cells_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_cells_z</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                      <span class="n">Lattice_Type</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Lattice&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate lattice structures with just simple parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Lattice_Type</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lattice_Type</span><span class="p">]</span>
        <span class="n">Radius</span> <span class="o">=</span> <span class="p">[</span><span class="n">Radius</span><span class="p">]</span>
        <span class="n">nameMaterial</span> <span class="o">=</span> <span class="s2">&quot;VeroClear&quot;</span>
        <span class="c1"># Define Default gradient properties</span>
        <span class="n">GradDimRule</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span>
        <span class="n">GradDimDirection</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">GradDimParameters</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="n">GradRadRule</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span>
        <span class="n">GradRadDirection</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">GradRadParameters</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="n">Multimat</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">GradMaterialDirection</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">gradDimProperty</span> <span class="o">=</span> <span class="p">[</span><span class="n">GradDimRule</span><span class="p">,</span> <span class="n">GradDimDirection</span><span class="p">,</span> <span class="n">GradDimParameters</span><span class="p">]</span>
        <span class="n">gradRadiusProperty</span> <span class="o">=</span> <span class="p">[</span><span class="n">GradRadRule</span><span class="p">,</span> <span class="n">GradRadDirection</span><span class="p">,</span> <span class="n">GradRadParameters</span><span class="p">]</span>
        <span class="n">gradMatProperty</span> <span class="o">=</span> <span class="p">[</span><span class="n">Multimat</span><span class="p">,</span> <span class="n">GradMaterialDirection</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="n">cell_size_y</span><span class="p">,</span> <span class="n">cell_size_z</span><span class="p">,</span> <span class="n">num_cells_x</span><span class="p">,</span> <span class="n">num_cells_y</span><span class="p">,</span> <span class="n">num_cells_z</span><span class="p">,</span> <span class="n">Lattice_Type</span><span class="p">,</span> <span class="n">Radius</span><span class="p">,</span>
                   <span class="n">nameMaterial</span><span class="p">,</span> <span class="n">gradRadiusProperty</span><span class="p">,</span> <span class="n">gradDimProperty</span><span class="p">,</span> <span class="n">gradMatProperty</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.hybridgeometry">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.hybridgeometry">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">hybridgeometry</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cell_size_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cell_size_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cell_size_z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                       <span class="n">simMethod</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Radius</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">latticeType</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">uncertaintyNode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                       <span class="n">periodicity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Lattice&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate hybrid geometry structure with just some parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nameMaterial</span> <span class="o">=</span> <span class="s2">&quot;VeroClear&quot;</span>
        <span class="c1"># Define Default gradient properties</span>
        <span class="n">GradDimRule</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span>
        <span class="n">GradDimDirection</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">GradDimParameters</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="n">GradRadRule</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span>
        <span class="n">GradRadDirection</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">GradRadParameters</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="n">Multimat</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">GradMaterialDirection</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">gradDimProperty</span> <span class="o">=</span> <span class="p">[</span><span class="n">GradDimRule</span><span class="p">,</span> <span class="n">GradDimDirection</span><span class="p">,</span> <span class="n">GradDimParameters</span><span class="p">]</span>
        <span class="n">gradRadiusProperty</span> <span class="o">=</span> <span class="p">[</span><span class="n">GradRadRule</span><span class="p">,</span> <span class="n">GradRadDirection</span><span class="p">,</span> <span class="n">GradRadParameters</span><span class="p">]</span>
        <span class="n">gradMatProperty</span> <span class="o">=</span> <span class="p">[</span><span class="n">Multimat</span><span class="p">,</span> <span class="n">GradMaterialDirection</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="n">cell_size_y</span><span class="p">,</span> <span class="n">cell_size_z</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">latticeType</span><span class="p">,</span>
                   <span class="n">Radius</span><span class="p">,</span> <span class="n">nameMaterial</span><span class="p">,</span> <span class="n">gradRadiusProperty</span><span class="p">,</span> <span class="n">gradDimProperty</span><span class="p">,</span> <span class="n">gradMatProperty</span><span class="p">,</span> <span class="n">simMethod</span><span class="p">,</span>
                   <span class="n">uncertaintyNode</span><span class="p">,</span> <span class="n">enable_periodicity</span><span class="o">=</span><span class="n">periodicity</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.loadLatticeObject">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.loadLatticeObject">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">loadLatticeObject</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;LatticeObject&quot;</span><span class="p">,</span> <span class="n">folder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Saved_Lattice&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Lattice&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a lattice object from a file.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        file_name: str</span>
<span class="sd">            Name of the file to load (with or without the &#39;.pkl&#39; extension).</span>
<span class="sd">        folder: str</span>
<span class="sd">            Folder where the file is located.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        Lattice</span>
<span class="sd">            The loaded lattice object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.pkl&quot;</span><span class="p">):</span>
            <span class="n">file_name</span> <span class="o">+=</span> <span class="s2">&quot;.pkl&quot;</span>

        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The file </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lattice loaded successfully from </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lattice</span></div>


<div class="viewcode-block" id="Lattice.from_json">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.from_json">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Lattice&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a lattice object from a JSON file.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        file_path: str</span>
<span class="sd">            Path to the JSON file containing lattice data.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        Lattice</span>
<span class="sd">            The loaded lattice object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

        <span class="c1"># Geometry</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">cell_size</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cell_size&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">number_of_cells</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;number_of_cells&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="n">cell_size_x</span> <span class="o">=</span> <span class="n">cell_size</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="n">cell_size_y</span> <span class="o">=</span> <span class="n">cell_size</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="n">cell_size_z</span> <span class="o">=</span> <span class="n">cell_size</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
        <span class="n">num_cells_x</span> <span class="o">=</span> <span class="n">number_of_cells</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="n">num_cells_y</span> <span class="o">=</span> <span class="n">number_of_cells</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="n">num_cells_z</span> <span class="o">=</span> <span class="n">number_of_cells</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
        <span class="n">radii</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;radii&quot;</span><span class="p">)</span>
        <span class="n">geom_types</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geom_types&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="n">cell_size_y</span><span class="p">,</span> <span class="n">cell_size_z</span><span class="p">,</span> <span class="n">num_cells_x</span><span class="p">,</span> <span class="n">num_cells_y</span><span class="p">,</span> <span class="n">num_cells_z</span><span class="p">,</span> <span class="n">radii</span><span class="p">,</span> <span class="n">geom_types</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing geometry parameters in JSON file.&quot;</span><span class="p">)</span>

        <span class="c1"># Gradient</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">radius_grad</span> <span class="o">=</span> <span class="n">gradient</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;radius&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">dim_grad</span> <span class="o">=</span> <span class="n">gradient</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cell_dimension&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">mat_grad</span> <span class="o">=</span> <span class="n">gradient</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;material&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="n">grad_radius_property</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rule&quot;</span><span class="p">,</span> <span class="s2">&quot;constant&quot;</span><span class="p">),</span>
            <span class="p">[</span><span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction_x&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
             <span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction_y&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
             <span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction_z&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)],</span>
            <span class="p">[</span><span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameter_x&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
             <span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameter_y&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
             <span class="n">radius_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameter_z&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span>
        <span class="p">]</span>

        <span class="n">grad_dim_property</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rule&quot;</span><span class="p">,</span> <span class="s2">&quot;constant&quot;</span><span class="p">),</span>
            <span class="p">[</span><span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction_x&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
             <span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction_y&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
             <span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction_z&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)],</span>
            <span class="p">[</span><span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameter_x&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
             <span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameter_y&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
             <span class="n">dim_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameter_z&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span>
        <span class="p">]</span>

        <span class="n">grad_mat_property</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">mat_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">mat_grad</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direction&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Supplementary</span>
        <span class="n">supplementary</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;suplementary&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">uncertainty_node</span> <span class="o">=</span> <span class="n">supplementary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;node_uncertainty&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># Erased blocks</span>
        <span class="n">erased_blocks_json</span> <span class="o">=</span> <span class="n">supplementary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;erased_blocks&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">erased_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">erased_blocks_json</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;start_point&quot;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dimensions_block&quot;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">erased_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                <span class="n">start</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">start</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">start</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
                <span class="n">dim</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">dim</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">dim</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">erased_blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">erased_blocks</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Symmetry</span>
        <span class="n">symmetries</span> <span class="o">=</span> <span class="n">supplementary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;symmetries&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">symmetry_lattice</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">symmetries</span><span class="p">:</span>
            <span class="n">sym_plane</span> <span class="o">=</span> <span class="n">symmetries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;plane&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">sym_point</span> <span class="o">=</span> <span class="n">symmetries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;reference_point&quot;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">symmetry_lattice</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;sym_plane&quot;</span><span class="p">:</span> <span class="n">sym_plane</span><span class="p">,</span>
                <span class="s2">&quot;sym_point&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">sym_point</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
                             <span class="n">sym_point</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
                             <span class="n">sym_point</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
            <span class="p">}</span>

        <span class="c1"># Simulation activation</span>
        <span class="n">sim_params</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;simulation_parameters&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">enable_simulation_properties</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">sim_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;enable&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
        <span class="n">material_name</span> <span class="o">=</span> <span class="n">sim_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;material&quot;</span><span class="p">,</span> <span class="s2">&quot;VeroClear&quot;</span><span class="p">)</span>
        <span class="n">periodicity</span> <span class="o">=</span> <span class="n">sim_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;periodicity&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="n">cell_size_y</span><span class="p">,</span> <span class="n">cell_size_z</span><span class="p">,</span>
                   <span class="n">num_cells_x</span><span class="p">,</span> <span class="n">num_cells_y</span><span class="p">,</span> <span class="n">num_cells_z</span><span class="p">,</span>
                   <span class="n">geom_types</span><span class="p">,</span> <span class="n">radii</span><span class="p">,</span>
                   <span class="n">material_name</span><span class="o">=</span><span class="n">material_name</span><span class="p">,</span>
                   <span class="n">grad_radius_property</span><span class="o">=</span><span class="n">grad_radius_property</span><span class="p">,</span>
                   <span class="n">grad_dim_property</span><span class="o">=</span><span class="n">grad_dim_property</span><span class="p">,</span>
                   <span class="n">grad_mat_property</span><span class="o">=</span><span class="n">grad_mat_property</span><span class="p">,</span>
                   <span class="n">uncertainty_node</span><span class="o">=</span><span class="n">uncertainty_node</span><span class="p">,</span>
                   <span class="n">enable_periodicity</span><span class="o">=</span><span class="n">periodicity</span><span class="p">,</span>
                   <span class="n">eraser_blocks</span><span class="o">=</span><span class="n">erased_blocks</span><span class="p">,</span>
                   <span class="n">symmetry_lattice</span><span class="o">=</span><span class="n">symmetry_lattice</span><span class="p">,</span>
                   <span class="n">enable_simulation_properties</span><span class="o">=</span><span class="n">enable_simulation_properties</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Lattice name: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Dimensions: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sizeX</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sizeY</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sizeZ</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Number of cells: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Cell size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Material: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">material_name</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;radii: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">string</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">generateLattice</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates lattice structure based on specified parameters.</span>

<span class="sd">        Return:</span>
<span class="sd">        --------</span>
<span class="sd">        cells: list of Cell objects</span>
<span class="sd">            List of cells in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xCellStartInit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">yCellStartInit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">zCellStartInit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">xCellStart</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">yCellStart</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">zCellStart</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">posCell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">xCellStart</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradDim</span><span class="p">[</span><span class="n">posCell</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xCellStart</span> <span class="o">=</span> <span class="n">xCellStartInit</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">yCellStart</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradDim</span><span class="p">[</span><span class="n">posCell</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">yCellStart</span> <span class="o">=</span> <span class="n">yCellStartInit</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">zCellStart</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradDim</span><span class="p">[</span><span class="n">posCell</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">zCellStart</span> <span class="o">=</span> <span class="n">zCellStartInit</span>
                    <span class="n">posCell</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                    <span class="n">initialCellSize</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span><span class="p">]</span>
                    <span class="n">startCellPos</span> <span class="o">=</span> <span class="p">[</span><span class="n">xCellStart</span><span class="p">,</span> <span class="n">yCellStart</span><span class="p">,</span> <span class="n">zCellStart</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isNotInErasedRegion</span><span class="p">(</span><span class="n">startCellPos</span><span class="p">):</span>
                        <span class="n">radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radii</span>
                        <span class="n">new_cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">posCell</span><span class="p">,</span> <span class="n">initialCellSize</span><span class="p">,</span> <span class="n">startCellPos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">,</span>
                                        <span class="n">radius</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradRadius</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradDim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradMat</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">uncertaintyNode</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshObject</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isCellInMesh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshObject</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">new_cell</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checkHybridCollision</span><span class="p">()</span>

<div class="viewcode-block" id="Lattice.getSizeLattice">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getSizeLattice">[docs]</a>
    <span class="k">def</span> <span class="nf">getSizeLattice</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the size of the lattice along each direction.</span>

<span class="sd">        Return:</span>
<span class="sd">        ---------</span>
<span class="sd">        sizeLattice: list of float in dim 3</span>
<span class="sd">            Length of the lattice in each direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sizeLattice</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">total_length</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">num_cells</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">][</span><span class="n">direction</span><span class="p">]</span>
            <span class="n">cell_size</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span><span class="p">][</span><span class="n">direction</span><span class="p">]</span>
            <span class="n">gradient_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">grad</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="k">for</span> <span class="n">grad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradDim</span><span class="p">[:</span><span class="n">num_cells</span><span class="p">]]</span>

            <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">gradient_factors</span><span class="p">:</span>
                <span class="n">total_length</span> <span class="o">+=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">cell_size</span>
            <span class="n">sizeLattice</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_length</span>

        <span class="k">return</span> <span class="n">sizeLattice</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">isNotInErasedRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startCellPos</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the cell is not in the erased region or inside the mesh.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        startCellPos: list of float</span>
<span class="sd">            (xStart, yStart, zStart) position of the cell to check.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        bool:</span>
<span class="sd">            True if the cell should be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># V√©rifier si le point est dans `erasedParts`</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">erasedParts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">delPart</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">erasedParts</span><span class="p">:</span>
                <span class="n">inside_erased</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">delPart</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">startCellPos</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">delPart</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">+</span> <span class="n">delPart</span><span class="p">[</span><span class="n">direction</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">inside_erased</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># La cellule est supprim√©e si elle est dans `erasedParts`</span>

        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># cell removed</span>

<div class="viewcode-block" id="Lattice.isPointInMesh">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.isPointInMesh">[docs]</a>
    <span class="k">def</span> <span class="nf">isPointInMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the point is inside the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshObject</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshObject</span><span class="o">.</span><span class="n">is_inside_mesh</span><span class="p">(</span><span class="n">point</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.isCellInMesh">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.isCellInMesh">[docs]</a>
    <span class="k">def</span> <span class="nf">isCellInMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the cell is in the erased region.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cellBoundaryPoint</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">getCellCornerCoordinates</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">cellBoundaryPoint</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isPointInMesh</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isPointInMesh</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">defineBeamNodeIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define index at each beam and node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">beamIndexed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nodeIndexed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nextBeamIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nextNodeIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Define already indexed beam and node</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">beamIndexed</span><span class="p">[</span><span class="n">beam</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextBeamIndex</span>
                    <span class="n">nextBeamIndex</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">nodeIndexed</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextNodeIndex</span>
                        <span class="n">nextNodeIndex</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Adding not indexed beam and node</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">beam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beamIndexed</span><span class="p">:</span>
                        <span class="n">beam</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">nextBeamIndex</span>
                        <span class="n">beamIndexed</span><span class="p">[</span><span class="n">beam</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextBeamIndex</span>
                        <span class="n">nextBeamIndex</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">beam</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">beamIndexed</span><span class="p">[</span><span class="n">beam</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeIndexed</span><span class="p">:</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">nextNodeIndex</span>
                            <span class="n">nodeIndexed</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextNodeIndex</span>
                            <span class="n">nextNodeIndex</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">nodeIndexed</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">defineCellIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define index at each cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cellIndexed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nextCellIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cellIndexed</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextCellIndex</span>
                <span class="n">nextCellIndex</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cell</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cellIndexed</span><span class="p">:</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">nextCellIndex</span>
                    <span class="n">cellIndexed</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextCellIndex</span>
                    <span class="n">nextCellIndex</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">defineCellNeighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define neighbours for each cell in the lattice, with periodic boundaries if enabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_dict</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">posCell</span><span class="p">):</span> <span class="n">cell</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">}</span>

        <span class="n">neighbor_offsets</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">localBoundaryBox</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodicity</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">erasedParts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getCellOccupancyMatrix</span><span class="p">()</span>
            <span class="n">localBoundaryBox</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">neighbourCells</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">boundaryBox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRelativeBoundaryBox</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="k">if</span> <span class="n">localBoundaryBox</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLatticeBoundaryBox</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">neighbor_offsets</span><span class="p">:</span>
                <span class="n">raw_pos</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">posCell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">posCell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">posCell</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodicity</span><span class="p">:</span>
                    <span class="c1"># periodicity X</span>
                    <span class="k">if</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">neighbor_x</span> <span class="o">=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">neighbor_x</span> <span class="o">=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">neighbor_x</span> <span class="o">=</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># periodicity Y</span>
                    <span class="k">if</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">neighbor_y</span> <span class="o">=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                        <span class="n">neighbor_y</span> <span class="o">=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">neighbor_y</span> <span class="o">=</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># periodicity Z</span>
                    <span class="k">if</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span>
                        <span class="n">neighbor_z</span> <span class="o">=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">5</span><span class="p">]:</span>
                        <span class="n">neighbor_z</span> <span class="o">=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">neighbor_z</span> <span class="o">=</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                    <span class="n">neighbor_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">neighbor_x</span><span class="p">,</span> <span class="n">neighbor_y</span><span class="p">,</span> <span class="n">neighbor_z</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">boundaryBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span>
                            <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="ow">and</span>
                            <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">raw_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">5</span><span class="p">]):</span>
                        <span class="k">continue</span>
                    <span class="n">neighbor_pos</span> <span class="o">=</span> <span class="n">raw_pos</span>
                <span class="k">if</span> <span class="n">neighbor_pos</span> <span class="ow">in</span> <span class="n">cell_dict</span><span class="p">:</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">addCellNeighbour</span><span class="p">(</span><span class="n">cell_dict</span><span class="p">[</span><span class="n">neighbor_pos</span><span class="p">])</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">getListAngleBeam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam</span><span class="p">:</span> <span class="s2">&quot;Beam&quot;</span><span class="p">,</span> <span class="n">pointbeams</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Beam&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate an angle between the considerate beam and beams contains in pointbeams</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        beam: Beam object</span>
<span class="sd">            Beam where an angle is computed on</span>
<span class="sd">        pointbeams: list of Beam object</span>
<span class="sd">            List of beam to calculate an angle with considered beam</span>

<span class="sd">        Return:</span>
<span class="sd">        ---------</span>
<span class="sd">        non_zero_anglebeam: list of an angle between considered beam and pointbeams beam list</span>
<span class="sd">        non_zero_radiusbeam: list of radius between a considered beam and pointbeams beam list</span>

<span class="sd">        Special case when pointbeams is an empty return max angle to minimize penalization zone</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">getAngleBetweenBeams</span><span class="p">(</span><span class="n">beam1</span><span class="p">,</span> <span class="n">beam2</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculates angle between 2 beams</span>

<span class="sd">            Return:</span>
<span class="sd">            --------</span>
<span class="sd">            Angle: float</span>
<span class="sd">                angle in degrees</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodicity</span><span class="p">:</span>
                <span class="c1"># V√©rification pour les coins (tags entre 1000 et 1007)</span>
                <span class="k">for</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">p1_candidate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">beam1</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point2</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">p1_candidate</span><span class="o">.</span><span class="n">tag</span> <span class="ow">and</span> <span class="mi">1000</span> <span class="o">&lt;=</span> <span class="n">p1_candidate</span><span class="o">.</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1007</span><span class="p">:</span>
                        <span class="n">p1</span> <span class="o">=</span> <span class="n">idx1</span>  <span class="c1"># Enregistrer l&#39;indice pour beam1</span>
                        <span class="k">for</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">p2_candidate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">beam2</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point2</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="n">p2_candidate</span><span class="o">.</span><span class="n">tag</span> <span class="ow">and</span> <span class="mi">1000</span> <span class="o">&lt;=</span> <span class="n">p2_candidate</span><span class="o">.</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1007</span><span class="p">:</span>
                                <span class="n">p2</span> <span class="o">=</span> <span class="n">idx2</span>  <span class="c1"># Enregistrer l&#39;indice pour beam2</span>
                                <span class="k">break</span>  <span class="c1"># Sortir de la boucle si une correspondance est trouv√©e</span>

                <span class="c1"># V√©rification pour les ar√™tes (tags sp√©cifiques)</span>
                <span class="k">if</span> <span class="n">p1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">p2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Ne v√©rifie les ar√™tes que si aucun coin n&#39;est trouv√©</span>
                    <span class="n">list_tag_edge</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">102</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">106</span><span class="p">,</span> <span class="mi">107</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">108</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">111</span><span class="p">],</span> <span class="p">[</span><span class="mi">101</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span> <span class="mi">110</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">tag_list</span> <span class="ow">in</span> <span class="n">list_tag_edge</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">p1_candidate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">beam1</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point2</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="n">p1_candidate</span><span class="o">.</span><span class="n">tag</span> <span class="ow">and</span> <span class="n">p1_candidate</span><span class="o">.</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">tag_list</span><span class="p">:</span>
                                <span class="n">p1</span> <span class="o">=</span> <span class="n">idx1</span>  <span class="c1"># Enregistrer l&#39;indice pour beam1</span>
                                <span class="k">for</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">p2_candidate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">beam2</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point2</span><span class="p">]):</span>
                                    <span class="k">if</span> <span class="n">p2_candidate</span><span class="o">.</span><span class="n">tag</span> <span class="ow">and</span> <span class="n">p2_candidate</span><span class="o">.</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">tag_list</span><span class="p">:</span>
                                        <span class="n">p2</span> <span class="o">=</span> <span class="n">idx2</span>  <span class="c1"># Enregistrer l&#39;indice pour beam2</span>
                                        <span class="k">break</span>  <span class="c1"># Sortir de la boucle si une correspondance est trouv√©e</span>

                <span class="k">if</span> <span class="n">p1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">p2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">list_face_tag</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">face_tag</span> <span class="ow">in</span> <span class="n">list_face_tag</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">p1_candidate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">beam1</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point2</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="n">p1_candidate</span><span class="o">.</span><span class="n">tag</span> <span class="ow">and</span> <span class="n">p1_candidate</span><span class="o">.</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">face_tag</span><span class="p">:</span>
                                <span class="n">p1</span> <span class="o">=</span> <span class="n">idx1</span>
                                <span class="k">for</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">p2_candidate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">beam2</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point2</span><span class="p">]):</span>
                                    <span class="k">if</span> <span class="n">p2_candidate</span><span class="o">.</span><span class="n">tag</span> <span class="ow">and</span> <span class="n">p2_candidate</span><span class="o">.</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">face_tag</span><span class="p">:</span>
                                        <span class="n">p2</span> <span class="o">=</span> <span class="n">idx2</span>
                                        <span class="k">break</span>

            <span class="k">if</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point1</span> <span class="o">==</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point2</span> <span class="o">-</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point1</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point2</span> <span class="o">-</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point1</span>
            <span class="k">elif</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point1</span> <span class="o">==</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point2</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point2</span> <span class="o">-</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point1</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point1</span> <span class="o">-</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point2</span>
            <span class="k">elif</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point2</span> <span class="o">==</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point1</span> <span class="o">-</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point2</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point2</span> <span class="o">-</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point1</span>
            <span class="k">elif</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point2</span> <span class="o">==</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point2</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point1</span> <span class="o">-</span> <span class="n">beam1</span><span class="o">.</span><span class="n">point2</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point1</span> <span class="o">-</span> <span class="n">beam2</span><span class="o">.</span><span class="n">point2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Beams are not connected at any point&quot;</span><span class="p">)</span>

            <span class="n">dot_product</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">u_norm</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">u</span><span class="p">))</span>
            <span class="n">v_norm</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">cos_theta</span> <span class="o">=</span> <span class="n">dot_product</span> <span class="o">/</span> <span class="p">(</span><span class="n">u_norm</span> <span class="o">*</span> <span class="n">v_norm</span><span class="p">)</span>
            <span class="n">cos_theta</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">cos_theta</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">cos_theta</span><span class="p">)</span>
            <span class="n">angle_deg</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">angle_deg</span>

        <span class="n">anglebeam</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">radiusBeam</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointbeams</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beampoint</span> <span class="ow">in</span> <span class="n">pointbeams</span><span class="p">:</span>
                <span class="n">radiusBeam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beampoint</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
                <span class="n">anglebeam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">getAngleBetweenBeams</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">beampoint</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radiusBeam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
            <span class="n">anglebeam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">179.9</span><span class="p">)</span>
        <span class="n">non_zero_anglebeam</span> <span class="o">=</span> <span class="p">[</span><span class="n">angle</span> <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">anglebeam</span> <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">]</span>
        <span class="n">non_zero_radiusbeam</span> <span class="o">=</span> <span class="p">[</span><span class="n">radius</span> <span class="k">for</span> <span class="n">angle</span><span class="p">,</span> <span class="n">radius</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">anglebeam</span><span class="p">,</span> <span class="n">radiusBeam</span><span class="p">)</span> <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">non_zero_anglebeam</span><span class="p">,</span> <span class="n">non_zero_radiusbeam</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">getConnectedBeams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beamList</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Beam&quot;</span><span class="p">],</span> <span class="n">beam</span><span class="p">:</span> <span class="s2">&quot;Beam&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Beam&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Beam&quot;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all beams connected to the interest beam.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        beamList: list of Beam objects</span>
<span class="sd">            List of all beams in the lattice.</span>
<span class="sd">        beam: Beam</span>
<span class="sd">            Beam of interest.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">point1beams</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">point2beams</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">edge_tags_list</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">102</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">106</span><span class="p">,</span> <span class="mi">107</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">108</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">111</span><span class="p">],</span> <span class="p">[</span><span class="mi">101</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span> <span class="mi">110</span><span class="p">]]</span>
        <span class="n">face_tags</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">]]</span>

        <span class="n">tag_checks</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1008</span><span class="p">),</span> <span class="s1">&#39;corner&#39;</span><span class="p">),</span> <span class="o">*</span><span class="p">[(</span><span class="n">tags</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">tags</span> <span class="ow">in</span> <span class="n">edge_tags_list</span><span class="p">],</span>
                      <span class="o">*</span><span class="p">[(</span><span class="n">tags</span><span class="p">,</span> <span class="s1">&#39;face&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">tags</span> <span class="ow">in</span> <span class="n">face_tags</span><span class="p">]]</span>

        <span class="k">def</span> <span class="nf">is_periodic_connected</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">b_idx</span><span class="p">,</span> <span class="n">tags_range</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check if the point p is periodic connected to the beam index b_idx</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">p_tag_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p_tag_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tags_range</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">bp1_tag</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b_idx</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">tag</span> <span class="ow">or</span> <span class="p">[])</span>
            <span class="n">bp2_tag</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b_idx</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">tag</span> <span class="ow">or</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">bp1_tag</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">bp2_tag</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tags_range</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">p_local</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">localTag</span><span class="p">)</span>
            <span class="n">bp1_local</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b_idx</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">localTag</span> <span class="ow">or</span> <span class="p">[])</span>
            <span class="n">bp2_local</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b_idx</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">localTag</span> <span class="ow">or</span> <span class="p">[])</span>

            <span class="k">if</span> <span class="n">tags_range</span> <span class="o">==</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1008</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">p_local</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tags_range</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bp1_local</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">bp2_local</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tags_range</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">p_local</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tags_range</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bp1_local</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">bp2_local</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tags_range</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">beamidx</span> <span class="ow">in</span> <span class="n">beamList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beamidx</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beamidx</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                <span class="n">point1beams</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">beamidx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beamidx</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beamidx</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                <span class="n">point2beams</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">beamidx</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodicity</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">tags_range</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tag_checks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_periodic_connected</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beamidx</span><span class="p">,</span> <span class="n">tags_range</span><span class="p">):</span>
                    <span class="n">point1beams</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">beamidx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_periodic_connected</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span> <span class="n">beamidx</span><span class="p">,</span> <span class="n">tags_range</span><span class="p">):</span>
                    <span class="n">point2beams</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">beamidx</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">point1beams</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">point2beams</span><span class="p">)</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">getAllAngles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates angles between beams in the lattice.</span>

<span class="sd">        Return:</span>
<span class="sd">        ---------</span>
<span class="sd">        angle:</span>
<span class="sd">            data structure =&gt; ((beam_index, Angle mininmum point 1, minRad1, Angle mininmum point 2, minRad2))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
        <span class="k">def</span> <span class="nf">findMinAngle</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">radii</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Find the Minimum angle between beams and radius connection to this particular beam</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">LValuesMax</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">LRadius</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">LAngle</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">radius</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">radii</span><span class="p">,</span> <span class="n">angles</span><span class="p">):</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">functionPenalizationLzone</span><span class="p">((</span><span class="n">radius</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="n">LValuesMax</span><span class="p">:</span>
                    <span class="n">LValuesMax</span> <span class="o">=</span> <span class="n">L</span>
                    <span class="n">LRadius</span> <span class="o">=</span> <span class="n">radius</span>
                    <span class="n">LAngle</span> <span class="o">=</span> <span class="n">angle</span>
            <span class="k">return</span> <span class="n">LAngle</span><span class="p">,</span> <span class="n">LRadius</span>

        <span class="c1"># Create the list of beam objects for each cell with neighbors cells</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">beamList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cellListNeighbours</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">neighbourCells</span>
            <span class="n">cellListNeighbours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>  <span class="c1"># Include the cell itself</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">cellListNeighbours</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">neighbour</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">beam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beamList</span><span class="p">:</span>
                        <span class="n">beamList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
            <span class="n">angleList</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="c1"># Determine beams on nodes</span>
                <span class="n">point1beams</span><span class="p">,</span> <span class="n">point2beams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getConnectedBeams</span><span class="p">(</span><span class="n">beamList</span><span class="p">,</span> <span class="n">beam</span><span class="p">)</span>
                <span class="c1"># Determine angles for all beams connected at the node</span>
                <span class="n">non_zero_anglebeam1</span><span class="p">,</span> <span class="n">non_zero_radiusbeam1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getListAngleBeam</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">point1beams</span><span class="p">)</span>
                <span class="n">non_zero_anglebeam2</span><span class="p">,</span> <span class="n">non_zero_radiusbeam2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getListAngleBeam</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">point2beams</span><span class="p">)</span>
                <span class="c1"># Find the lowest angle</span>
                <span class="n">LAngle1</span><span class="p">,</span> <span class="n">LRadius1</span> <span class="o">=</span> <span class="n">findMinAngle</span><span class="p">(</span><span class="n">non_zero_anglebeam1</span><span class="p">,</span> <span class="n">non_zero_radiusbeam1</span><span class="p">)</span>
                <span class="n">LAngle2</span><span class="p">,</span> <span class="n">LRadius2</span> <span class="o">=</span> <span class="n">findMinAngle</span><span class="p">(</span><span class="n">non_zero_anglebeam2</span><span class="p">,</span> <span class="n">non_zero_radiusbeam2</span><span class="p">)</span>
                <span class="n">angleList</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">LRadius1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">LAngle1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">LRadius2</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">LAngle2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">beam</span><span class="o">.</span><span class="n">setAngle</span><span class="p">(</span><span class="n">angleList</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">getMinMaxValues</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes extremum values of coordinates in the lattice.</span>

<span class="sd">        Return:</span>
<span class="sd">        --------</span>
<span class="sd">        ExtrumumValues: tuple of floats (xMin, xMax, yMin, yMax, zMin, zMax)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No cells in the lattice.&quot;</span><span class="p">)</span>

        <span class="c1"># Flatten the list of nodes from all cells</span>
        <span class="n">all_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No nodes in the cells of the lattice.&quot;</span><span class="p">)</span>

        <span class="c1"># Extract coordinates</span>
        <span class="n">x_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">all_nodes</span><span class="p">]</span>
        <span class="n">y_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">all_nodes</span><span class="p">]</span>
        <span class="n">z_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">all_nodes</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">xMin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_values</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yMin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_values</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zMin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">z_values</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">z_values</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setLatticeDimensionsDict</span><span class="p">()</span>

<div class="viewcode-block" id="Lattice.setLatticeDimensionsDict">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.setLatticeDimensionsDict">[docs]</a>
    <span class="k">def</span> <span class="nf">setLatticeDimensionsDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set lattice dimensions in a dictionary format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latticeDimensionsDict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;xMin&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMin</span><span class="p">,</span>
            <span class="s2">&quot;xMax&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMax</span><span class="p">,</span>
            <span class="s2">&quot;yMin&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMin</span><span class="p">,</span>
            <span class="s2">&quot;yMax&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMax</span><span class="p">,</span>
            <span class="s2">&quot;zMin&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMin</span><span class="p">,</span>
            <span class="s2">&quot;zMax&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMax</span>
        <span class="p">}</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">setBeamNodeMod</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies beam and node data to model lattice structures for simulation with rigidity penalization at node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">beamsToRemove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">beamToAdd</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="n">lengthMod</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">getLengthMod</span><span class="p">()</span>
                <span class="n">pointExt1</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">getPointOnBeamFromDistance</span><span class="p">(</span><span class="n">lengthMod</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pointExt1Obj</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">pointExt1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pointExt1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pointExt1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">pointExt1Obj</span><span class="o">.</span><span class="n">nodeMod</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">pointExt2</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">getPointOnBeamFromDistance</span><span class="p">(</span><span class="n">lengthMod</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">pointExt2Obj</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">pointExt2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pointExt2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pointExt2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">pointExt2Obj</span><span class="o">.</span><span class="n">nodeMod</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">b1</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">pointExt1Obj</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span>
                          <span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                <span class="n">b1</span><span class="o">.</span><span class="n">setBeamMod</span><span class="p">()</span>
                <span class="n">b2</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">pointExt1Obj</span><span class="p">,</span> <span class="n">pointExt2Obj</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                <span class="n">b3</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">pointExt2Obj</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span>
                          <span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                <span class="n">b3</span><span class="o">.</span><span class="n">setBeamMod</span><span class="p">()</span>

                <span class="n">beamToAdd</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">))</span>

                <span class="n">beamsToRemove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">addingBeam</span> <span class="ow">in</span> <span class="n">beamToAdd</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">addBeam</span><span class="p">(</span><span class="n">addingBeam</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">beamsToRemove</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">removeBeam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>

        <span class="c1"># Update index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defineBeamNodeIndex</span><span class="p">()</span>

<div class="viewcode-block" id="Lattice.removeCell">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.removeCell">[docs]</a>
    <span class="k">def</span> <span class="nf">removeCell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a cell from the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ------------</span>
<span class="sd">        index: int</span>
<span class="sd">            index of the cell to remove</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Invalid cell index.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.findMinimumBeamLength">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.findMinimumBeamLength">[docs]</a>
    <span class="k">def</span> <span class="nf">findMinimumBeamLength</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find minimum beam length</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        minLength: float</span>
<span class="sd">            Length of the smallest beam in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">minLength</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">minLength</span> <span class="o">&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">getLength</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.0001</span> <span class="ow">and</span> <span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">beam</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">minLength</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">getLength</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">minLength</span></div>


<div class="viewcode-block" id="Lattice.getTagList">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getTagList">[docs]</a>
    <span class="k">def</span> <span class="nf">getTagList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the tag for all points in lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        tagList: list of int</span>
<span class="sd">            List of all tags of each point in lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tagList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodeAlreadyAdded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeAlreadyAdded</span><span class="p">:</span>
                        <span class="n">tagList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
                        <span class="n">nodeAlreadyAdded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tagList</span></div>


<div class="viewcode-block" id="Lattice.getTagListBoundary">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getTagListBoundary">[docs]</a>
    <span class="k">def</span> <span class="nf">getTagListBoundary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the tag for all points in lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        tagList: list of int</span>
<span class="sd">            List of all tags of each point in lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tagList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodeAlreadyAdded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeAlreadyAdded</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isNodeOnBoundary</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                        <span class="n">tagList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
                        <span class="n">nodeAlreadyAdded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tagList</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">applyTagToAllPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign a tag to all nodes in the lattice structure.</span>
<span class="sd">        Tags are assigned relative to either the global bounding box</span>
<span class="sd">        or a local (cell-relative) bounding box if erased parts are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">use_local_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">erasedParts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">use_local_box</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getCellOccupancyMatrix</span><span class="p">()</span>

        <span class="n">global_box</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">use_local_box</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLatticeBoundaryBox</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">local_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRelativeBoundaryBox</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="k">if</span> <span class="n">use_local_box</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">tag</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tagPoint</span><span class="p">(</span><span class="n">local_box</span> <span class="k">if</span> <span class="n">use_local_box</span> <span class="k">else</span> <span class="n">global_box</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span>

<div class="viewcode-block" id="Lattice.getCellOccupancyMatrix">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getCellOccupancyMatrix">[docs]</a>
    <span class="k">def</span> <span class="nf">getCellOccupancyMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a 3D boolean matrix indicating presence of a cell at each (i, j, k) position.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        occupancy_matrix: np.ndarray of shape (num_cells_x, num_cells_y, num_cells_z)</span>
<span class="sd">            True if a cell is present at the corresponding position, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cells_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells_z</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">posCell</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span></div>


<div class="viewcode-block" id="Lattice.getCellsAt">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getCellsAt">[docs]</a>
    <span class="k">def</span> <span class="nf">getCellsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all cells at a specific index along a specified axis.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        axis: str</span>
<span class="sd">            Axis to query (&#39;x&#39;, &#39;y&#39;, or &#39;z&#39;).</span>
<span class="sd">        index: int</span>
<span class="sd">            Index along the specified axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span><span class="p">[:,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy_matrix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axis must be &#39;x&#39;, &#39;y&#39;, or &#39;z&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.getRelativeBoundaryBox">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getRelativeBoundaryBox">[docs]</a>
    <span class="k">def</span> <span class="nf">getRelativeBoundaryBox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the relative boundary box of a cell in the lattice.</span>
<span class="sd">        It corresponds to the minimum and maximum dimension of the lattice for each axis with cell continuity.</span>
<span class="sd">        Useful for structures with erased parts or periodic boundaries.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        cell: Cell object</span>
<span class="sd">            The cell for which the boundary box is computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">posCell</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span>
                <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span>
        <span class="p">):</span>
            <span class="n">arrayCell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCellsAt</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="k">for</span> <span class="n">cellIn</span> <span class="ow">in</span> <span class="n">arrayCell</span><span class="p">:</span>
                <span class="n">cellInBoundaryBox</span> <span class="o">=</span> <span class="n">cellIn</span><span class="o">.</span><span class="n">getCellBoundaryBox</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="n">cellInBoundaryBox</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="n">cellInBoundaryBox</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="n">cellInBoundaryBox</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_val</span><span class="p">:</span>
                    <span class="n">max_val</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_val</span><span class="p">)</span>
            <span class="n">bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bbox</span></div>


<div class="viewcode-block" id="Lattice.getLatticeBoundaryBox">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getLatticeBoundaryBox">[docs]</a>
    <span class="k">def</span> <span class="nf">getLatticeBoundaryBox</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the boundary box of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xMin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMax</span><span class="p">]</span></div>


<div class="viewcode-block" id="Lattice.getConnectedNode">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getConnectedNode">[docs]</a>
    <span class="k">def</span> <span class="nf">getConnectedNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;Point&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Point&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all nodes connected to the input node with a beam</span>

<span class="sd">        Parameter:</span>
<span class="sd">        -----------</span>
<span class="sd">        node: point object</span>

<span class="sd">        Return:</span>
<span class="sd">        --------</span>
<span class="sd">        connectedNode: List of a point object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">connectedNode</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodeIndexRef</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">nodeIndexRef</span><span class="p">:</span>
                    <span class="n">connectedNode</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">nodeIndexRef</span><span class="p">:</span>
                    <span class="n">connectedNode</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">connectedNode</span></div>


<div class="viewcode-block" id="Lattice.findBoundaryBeams">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.findBoundaryBeams">[docs]</a>
    <span class="k">def</span> <span class="nf">findBoundaryBeams</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Beam&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find boundary beams and change the type of beam</span>

<span class="sd">        Return:</span>
<span class="sd">        -------</span>
<span class="sd">        boundaryBeams: List of a beam object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boundaryBeams</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isNodeOnBoundary</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">isNodeOnBoundary</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">):</span>
                    <span class="n">beam</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="n">boundaryBeams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">boundaryBeams</span></div>


<div class="viewcode-block" id="Lattice.isNodeOnBoundary">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.isNodeOnBoundary">[docs]</a>
    <span class="k">def</span> <span class="nf">isNodeOnBoundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;Point&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get boolean that give information of boundary node</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        node : Point object</span>

<span class="sd">        Returns:</span>
<span class="sd">        ----------</span>
<span class="sd">        boolean: (True if node on boundary)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMin</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMax</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMin</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMax</span> <span class="ow">or</span>
                <span class="n">node</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMin</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMax</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.findBoundaryNodes">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.findBoundaryNodes">[docs]</a>
    <span class="k">def</span> <span class="nf">findBoundaryNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Point&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find boundary nodes</span>

<span class="sd">        Returns:</span>
<span class="sd">        ---------</span>
<span class="sd">        boundaryNodes: List of a point object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boundaryNodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMin</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMax</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMin</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMax</span> <span class="ow">or</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMin</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMax</span><span class="p">):</span>
                        <span class="n">boundaryNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">boundaryNodes</span></div>


<div class="viewcode-block" id="Lattice.getName">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getName">[docs]</a>
    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the name of the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        ---------</span>
<span class="sd">        name: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nameList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;BCC&quot;</span><span class="p">,</span>  <span class="c1"># 0</span>
            <span class="s2">&quot;Octet&quot;</span><span class="p">,</span>  <span class="c1"># 1</span>
            <span class="s2">&quot;OctetExt&quot;</span><span class="p">,</span>  <span class="c1"># 2</span>
            <span class="s2">&quot;OctetInt&quot;</span><span class="p">,</span>  <span class="c1"># 3</span>
            <span class="s2">&quot;BCCZ&quot;</span><span class="p">,</span>  <span class="c1"># 4</span>
            <span class="s2">&quot;Cubic&quot;</span><span class="p">,</span>  <span class="c1"># 5</span>
            <span class="s2">&quot;OctahedronZ&quot;</span><span class="p">,</span>  <span class="c1"># 6</span>
            <span class="s2">&quot;OctahedronZcross&quot;</span><span class="p">,</span>  <span class="c1"># 7</span>
            <span class="s2">&quot;Kelvin&quot;</span><span class="p">,</span>  <span class="c1"># 8</span>
            <span class="s2">&quot;CubicV2&quot;</span><span class="p">,</span>  <span class="c1"># 9 (centered)</span>
            <span class="s2">&quot;CubicV3&quot;</span><span class="p">,</span>  <span class="c1"># 10</span>
            <span class="s2">&quot;CubicV4&quot;</span><span class="p">,</span>  <span class="c1"># 11</span>
            <span class="s2">&quot;NewlatticeUnknown&quot;</span><span class="p">,</span>  <span class="c1"># 12 GPT generated</span>
            <span class="s2">&quot;Diamond&quot;</span><span class="p">,</span>  <span class="c1"># 13</span>
            <span class="s2">&quot;Auxetic&quot;</span>  <span class="c1"># 14</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Hybrid&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">nameList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_simulation_properties</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s2">&quot;Mod&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>


<div class="viewcode-block" id="Lattice.checkHybridCollision">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.checkHybridCollision">[docs]</a>
    <span class="k">def</span> <span class="nf">checkHybridCollision</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if beam in hybrid configuration is cut by a point in the geometry</span>
<span class="sd">        Change the beam configuration of collisionned beams</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cellPoints</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">getAllPoints</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">cellPoints</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">isPointOnBeam</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                        <span class="n">typeBeamToRemove</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">type</span>  <span class="c1"># Get beam to remove type to apply in new separated beams</span>
                        <span class="n">beam1</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">typeBeamToRemove</span><span class="p">)</span>
                        <span class="n">beam2</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">typeBeamToRemove</span><span class="p">)</span>
                        <span class="n">cell</span><span class="o">.</span><span class="n">removeBeam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
                        <span class="n">cell</span><span class="o">.</span><span class="n">addBeam</span><span class="p">(</span><span class="n">beam1</span><span class="p">)</span>
                        <span class="n">cell</span><span class="o">.</span><span class="n">addBeam</span><span class="p">(</span><span class="n">beam2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.getPosData">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getPosData">[docs]</a>
    <span class="k">def</span> <span class="nf">getPosData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves position data for the lattice.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        posData: list of list of float</span>
<span class="sd">            List of node positions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">posData</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodeAlreadyAdded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeAlreadyAdded</span><span class="p">:</span>
                        <span class="n">posData</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">getPos</span><span class="p">()])</span>
                        <span class="n">nodeAlreadyAdded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">posData</span></div>


<div class="viewcode-block" id="Lattice.getEdgeIndex">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getEdgeIndex">[docs]</a>
    <span class="k">def</span> <span class="nf">getEdgeIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves edge index data for the lattice.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        edgeIndex: list of list of int</span>
<span class="sd">            List of edge index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edgeIndex</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">beamAlreadyAdded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beamAlreadyAdded</span><span class="p">:</span>
                    <span class="n">edgeIndex</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>
                    <span class="n">beamAlreadyAdded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">edgeIndex</span></div>


<div class="viewcode-block" id="Lattice.getBeamType">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getBeamType">[docs]</a>
    <span class="k">def</span> <span class="nf">getBeamType</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves beam type data for the lattice.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        beamType: list of int</span>
<span class="sd">            List of beam types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">beamType</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">beamAlreadyAdded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beamAlreadyAdded</span><span class="p">:</span>
                    <span class="n">beamType</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">beamType</span></div>


<div class="viewcode-block" id="Lattice.getAllBeamLength">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getAllBeamLength">[docs]</a>
    <span class="k">def</span> <span class="nf">getAllBeamLength</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves beam length data for the lattice.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        beamLength: list of float</span>
<span class="sd">            List of beam lengths</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">beamLength</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">beamAlreadyAdded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beamAlreadyAdded</span><span class="p">:</span>
                    <span class="n">beamLength</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">beam</span><span class="o">.</span><span class="n">length</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">beamLength</span></div>


<div class="viewcode-block" id="Lattice.changeHybridData">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.changeHybridData">[docs]</a>
    <span class="k">def</span> <span class="nf">changeHybridData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hybridRadiusData</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change radius data for hybrid lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ------------</span>
<span class="sd">        hybridRadiusData: list of float</span>
<span class="sd">            List of radius data for hybrid lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hybridRadiusData</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid hybrid radius data.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">modBeam</span><span class="p">:</span>
                    <span class="n">beam</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">hybridRadiusData</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">]</span> <span class="o">*</span> <span class="n">beam</span><span class="o">.</span><span class="n">penalizationCoefficient</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">beam</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">hybridRadiusData</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">]</span></div>


<div class="viewcode-block" id="Lattice.attractorLattice">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.attractorLattice">[docs]</a>
    <span class="k">def</span> <span class="nf">attractorLattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PointAttractorList</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                         <span class="n">inverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attract lattice to a specific point</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        PointAttractor: list of float in dim 3</span>
<span class="sd">            Coordinates of the attractor point (default: None)</span>
<span class="sd">        alpha: float</span>
<span class="sd">            Coefficient of attraction (default: 0.5)</span>
<span class="sd">        inverse: bool</span>
<span class="sd">            If True, points farther away are attracted less (default: False)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate distance between two points</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">point2</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">point1</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">point2</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">point1</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">point2</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">point1</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">movePointAttracted</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">attractorPoint</span><span class="p">,</span> <span class="n">alpha_coeff</span><span class="p">,</span> <span class="n">inverse_bool</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Move point1 relative from attractorPoint with coefficient alpha</span>

<span class="sd">            Parameters:</span>
<span class="sd">            -----------</span>
<span class="sd">            point: Point object</span>
<span class="sd">                Point to move</span>
<span class="sd">            attractorPoint: Point object</span>
<span class="sd">                Attractor point</span>
<span class="sd">            alpha_coeff: float</span>
<span class="sd">                Coefficient of attraction</span>
<span class="sd">            inverse: bool</span>
<span class="sd">                If True, points farther away are attracted less</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">Length</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">attractorPoint</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">inverse_bool</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">alpha_coeff</span> <span class="o">/</span> <span class="n">Length</span> <span class="k">if</span> <span class="n">Length</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">alpha_coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">alpha_coeff</span> <span class="o">*</span> <span class="n">Length</span>

            <span class="n">DR</span> <span class="o">=</span> <span class="p">[(</span><span class="n">attractorPoint</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span><span class="p">,</span> <span class="p">(</span><span class="n">attractorPoint</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span><span class="p">,</span>
                  <span class="p">(</span><span class="n">attractorPoint</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">point</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span><span class="p">]</span>

            <span class="n">pointMod</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">z</span><span class="p">]</span>
            <span class="n">pointMod</span> <span class="o">=</span> <span class="p">[</span><span class="n">p1</span> <span class="o">+</span> <span class="n">p2</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pointMod</span><span class="p">,</span> <span class="n">DR</span><span class="p">)]</span>
            <span class="n">point</span><span class="o">.</span><span class="n">movePoint</span><span class="p">(</span><span class="n">pointMod</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pointMod</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pointMod</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">PointAttractorList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pointAttractor</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pointAttractor</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">PointAttractorList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PointAttractorList</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">PointAttractorList</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="n">movePointAttracted</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">pointAttractor</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">inverse</span><span class="p">)</span>
                <span class="n">movePointAttracted</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span> <span class="n">pointAttractor</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">inverse</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getMinMaxValues</span><span class="p">()</span></div>


<div class="viewcode-block" id="Lattice.curveLattice">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.curveLattice">[docs]</a>
    <span class="k">def</span> <span class="nf">curveLattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">center_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">center_z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                     <span class="n">curvature_strength</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Curve the lattice structure around a given center.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        center_x: float</span>
<span class="sd">            The x-coordinate of the center of the curvature.</span>
<span class="sd">        center_y: float</span>
<span class="sd">            The y-coordinate of the center of the curvature.</span>
<span class="sd">        center_z: float</span>
<span class="sd">            The z-coordinate of the center of the curvature.</span>
<span class="sd">        curvature_strength: float (default: 0.1)</span>
<span class="sd">            The strength of the curvature applied to the lattice.</span>
<span class="sd">            Positive values curve upwards, negative values curve downwards.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">z</span>
                    <span class="c1"># Calculate the distance from the center of curvature</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">center_x</span>
                    <span class="n">dy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">center_y</span>
                    <span class="n">dz</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">center_z</span>
                    <span class="n">new_z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">curvature_strength</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dz</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">movePoint</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">new_z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getMinMaxValues</span><span class="p">()</span></div>


<div class="viewcode-block" id="Lattice.cylindrical_transform">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.cylindrical_transform">[docs]</a>
    <span class="k">def</span> <span class="nf">cylindrical_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply cylindrical transformation to the lattice structure.</span>
<span class="sd">        To create stent structures, 1 cell in the X direction is required and you can choose any number of cells in</span>
<span class="sd">        the Y and Z direction.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        radius: float</span>
<span class="sd">            radii of the cylinder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizeY</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">z</span>
                    <span class="c1"># Convert Cartesian coordinates (x, y, z) to cylindrical coordinates (r, theta, z)</span>
                    <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">max_y</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>  <span class="c1"># theta = (y / total height) * 2 * pi</span>
                    <span class="n">new_x</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                    <span class="n">new_y</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">movePoint</span><span class="p">(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getMinMaxValues</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deleteDuplicatedBeams</span><span class="p">()</span></div>


<div class="viewcode-block" id="Lattice.moveToCylinderForm">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.moveToCylinderForm">[docs]</a>
    <span class="k">def</span> <span class="nf">moveToCylinderForm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move the lattice to a cylindrical form.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        radius: float</span>
<span class="sd">            radii of the cylinder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">radius</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMax</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The radius of the cylinder is too small: minimum value = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMax</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Find moving distance</span>
        <span class="k">def</span> <span class="nf">formula</span><span class="p">(</span><span class="n">x_coords</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Formula to calculate the new z-coordinate of the node.</span>

<span class="sd">            Parameters:</span>
<span class="sd">            -----------</span>
<span class="sd">            x: float</span>
<span class="sd">                x-coordinate of the node.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">radius</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x_coords</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMax</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">z</span>
                    <span class="n">new_z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">formula</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">movePoint</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">new_z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getMinMaxValues</span><span class="p">()</span></div>


<div class="viewcode-block" id="Lattice.fitToSurface">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.fitToSurface">[docs]</a>
    <span class="k">def</span> <span class="nf">fitToSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">equation</span><span class="p">:</span> <span class="nb">callable</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust the lattice nodes to follow a surface defined by an equation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        equation : callable</span>
<span class="sd">            Function representing the surface. For example, a lambda function or a normal function.</span>
<span class="sd">            Example: lambda x, y: x**2 + y**2 (for a paraboloid).</span>
<span class="sd">        mode : str</span>
<span class="sd">            Adjustment mode:</span>
<span class="sd">            - &quot;z&quot;: Adjust nodes on a surface (z = f(x, y)).</span>
<span class="sd">            - &quot;z_plan&quot;: Adjust nodes on a plan (z = f(x, y)) without changing the z-coordinate.</span>
<span class="sd">        params : dict</span>
<span class="sd">            Additional parameters for the equation or mode (e.g., radius, angle, etc.).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nodeAlreadyChanged</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">z</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeAlreadyChanged</span><span class="p">:</span>
                        <span class="n">nodeAlreadyChanged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                        <span class="c1"># Adjust for a surface \( z = f(x, y) \)</span>
                        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span>
                            <span class="n">new_z</span> <span class="o">=</span> <span class="n">equation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
                            <span class="n">new_z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">new_z</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">movePoint</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">new_z</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;z_plan&quot;</span><span class="p">:</span>
                            <span class="n">new_z</span> <span class="o">=</span> <span class="n">equation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">movePoint</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">new_z</span><span class="p">)</span>

                        <span class="c1"># Other modes can be added here (e.g. cylindrical, spherical)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mode &#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39; non support√©.&quot;</span><span class="p">)</span>

        <span class="c1"># Update lattice limits after adjustment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getMinMaxValues</span><span class="p">()</span></div>


<div class="viewcode-block" id="Lattice.deleteDuplicatedBeams">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.deleteDuplicatedBeams">[docs]</a>
    <span class="k">def</span> <span class="nf">deleteDuplicatedBeams</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete duplicated beams in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">beamList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beamList</span><span class="p">:</span>
                    <span class="n">beamList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">removeBeam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.getRelativeDensityConstraint">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getRelativeDensityConstraint">[docs]</a>
    <span class="k">def</span> <span class="nf">getRelativeDensityConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relativeDensityMax</span><span class="p">,</span> <span class="n">geomScheme</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get relative density of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">relativeDensity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRelativeDensity</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Relative density: &quot;</span><span class="p">,</span> <span class="n">relativeDensity</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">relativeDensity</span> <span class="o">-</span> <span class="n">relativeDensityMax</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Relative density maximum: &quot;</span><span class="p">,</span> <span class="n">relativeDensityMax</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Relative density error: &quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">error</span></div>


<div class="viewcode-block" id="Lattice.getRelativeDensity">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getRelativeDensity">[docs]</a>
    <span class="k">def</span> <span class="nf">getRelativeDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geomScheme</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get mean relative density of all cells in lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        meanRelDens: float</span>
<span class="sd">            Mean relative density of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cellRelDens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">krigingModelRelativeDensity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cellRelDens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">getRelativeDensityKriging</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">krigingModelRelativeDensity</span><span class="p">,</span> <span class="n">geomScheme</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cellRelDens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">getRelativeDensityCell</span><span class="p">())</span>
        <span class="n">meanRelDens</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">cellRelDens</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">meanRelDens</span></div>


<div class="viewcode-block" id="Lattice.defineRelativeDensityFunction">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.defineRelativeDensityFunction">[docs]</a>
    <span class="k">def</span> <span class="nf">defineRelativeDensityFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define relative density function</span>
<span class="sd">        Possible to define a more complex function with dependency on hybrid cells</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        degree: int</span>
<span class="sd">            Degree of the polynomial function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relativeDensityPoly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fictiveCell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_size_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size_z</span><span class="p">],</span>
                               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradRadius</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradDim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradMat</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">uncertaintyNode</span><span class="p">)</span>
            <span class="n">domainRadius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idxRad</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">)):</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">))</span>
                <span class="n">relativeDensity</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">domainIdx</span> <span class="ow">in</span> <span class="n">domainRadius</span><span class="p">:</span>
                    <span class="n">radius</span><span class="p">[</span><span class="n">idxRad</span><span class="p">]</span> <span class="o">=</span> <span class="n">domainIdx</span>
                    <span class="n">fictiveCell</span><span class="o">.</span><span class="n">changeBeamRadius</span><span class="p">([</span><span class="n">radius</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradRadius</span><span class="p">)</span>
                    <span class="n">relativeDensity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fictiveCell</span><span class="o">.</span><span class="n">getRelativeDensityCell</span><span class="p">())</span>
                <span class="n">poly_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">domainRadius</span><span class="p">,</span> <span class="n">relativeDensity</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">poly_coeffs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relativeDensityPoly</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relativeDensityPolyDeriv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">deriv</span><span class="p">())</span></div>


<div class="viewcode-block" id="Lattice.getRelativeDensityGradient">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getRelativeDensityGradient">[docs]</a>
    <span class="k">def</span> <span class="nf">getRelativeDensityGradient</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get relative density gradient of the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        grad: list of float</span>
<span class="sd">            Gradient of relative density</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relativeDensityPoly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defineRelativeDensityFunction</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relativeDensityPoly</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid radius data.&quot;</span><span class="p">)</span>

        <span class="n">grad</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">grad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">getRelativeDensityGradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relativeDensityPolyDeriv</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">grad</span></div>


<div class="viewcode-block" id="Lattice.getRelativeDensityGradientKriging">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getRelativeDensityGradientKriging">[docs]</a>
    <span class="k">def</span> <span class="nf">getRelativeDensityGradientKriging</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geomScheme</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get relative density gradient of the lattice using kriging model</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        grad: list of float</span>
<span class="sd">            Gradient of relative density</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">numberOfCells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geomScheme</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">geomScheme</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">gradient3Geom</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">getRelativeDensityGradientKrigingCell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">krigingModelRelativeDensity</span><span class="p">,</span>
                                                                       <span class="n">geomScheme</span><span class="p">)</span> <span class="o">/</span> <span class="n">numberOfCells</span>
            <span class="n">grad</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">gradient3Geom</span><span class="p">[</span><span class="n">geomScheme</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">grad</span></div>


<div class="viewcode-block" id="Lattice.getRadiusContinuityDifference">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getRadiusContinuityDifference">[docs]</a>
    <span class="k">def</span> <span class="nf">getRadiusContinuityDifference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the difference in radius between connected beams in the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        delta: float</span>
<span class="sd">            Minimum difference in radius between connected cells</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">radiusContinuityDifference</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">radiusCell</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">radius</span>
            <span class="k">for</span> <span class="n">neighbours</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">neighbourCells</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">rad</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">radiusCell</span><span class="p">)):</span>
                    <span class="n">radiusContinuityDifference</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">radiusCell</span><span class="p">[</span><span class="n">rad</span><span class="p">]</span> <span class="o">-</span> <span class="n">neighbours</span><span class="o">.</span><span class="n">radius</span><span class="p">[</span><span class="n">rad</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">radiusContinuityDifference</span></div>


<div class="viewcode-block" id="Lattice.getRadiusContinuityJacobian">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getRadiusContinuityJacobian">[docs]</a>
    <span class="k">def</span> <span class="nf">getRadiusContinuityJacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Jacobian of the radius continuity constraint.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Jacobian matrix of shape (num_constraints, num_radii)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">constraint_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">radiusCell</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">radius</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">neighbourCells</span><span class="p">:</span>
                <span class="n">radiusNeighbour</span> <span class="o">=</span> <span class="n">neighbour</span><span class="o">.</span><span class="n">radius</span>
                <span class="k">for</span> <span class="n">rad</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">radiusCell</span><span class="p">)):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">radiusCell</span><span class="p">)</span> <span class="o">+</span> <span class="n">rad</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">neighbour</span><span class="o">.</span><span class="n">index</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">radiusCell</span><span class="p">)</span> <span class="o">+</span> <span class="n">rad</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="n">radiusCell</span><span class="p">[</span><span class="n">rad</span><span class="p">]</span> <span class="o">-</span> <span class="n">radiusNeighbour</span><span class="p">[</span><span class="n">rad</span><span class="p">]</span>

                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constraint_index</span><span class="p">)</span>
                    <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">diff</span><span class="p">)</span>

                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constraint_index</span><span class="p">)</span>
                    <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">diff</span><span class="p">)</span>

                    <span class="n">constraint_index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">jacobian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">constraint_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberParametersOptimization</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="n">jacobian</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="n">jacobian</span></div>


<div class="viewcode-block" id="Lattice.changeBeamRadiusForType">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.changeBeamRadiusForType">[docs]</a>
    <span class="k">def</span> <span class="nf">changeBeamRadiusForType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeToChange</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">newRadius</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change radius of beam for specific type</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        typeToChange: int</span>
<span class="sd">            Type of beam to change</span>
<span class="sd">        newRadius: float</span>
<span class="sd">            New radius of beam</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">typeToChange</span><span class="p">:</span>
                    <span class="n">beam</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">newRadius</span></div>


<div class="viewcode-block" id="Lattice.getNumberOfBeams">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getNumberOfBeams">[docs]</a>
    <span class="k">def</span> <span class="nf">getNumberOfBeams</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get number of beams in the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        numBeams: int</span>
<span class="sd">            Number of beams in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numBeams</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">numBeams</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numBeams</span></div>


<div class="viewcode-block" id="Lattice.getNumberOfNodes">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getNumberOfNodes">[docs]</a>
    <span class="k">def</span> <span class="nf">getNumberOfNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get number of nodes in the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        numNodes: int</span>
<span class="sd">            Number of nodes in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numNodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nodeIndexList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeIndexList</span><span class="p">:</span>
                        <span class="n">nodeIndexList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                        <span class="n">numNodes</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">numNodes</span></div>


<div class="viewcode-block" id="Lattice.latticeInfo">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.latticeInfo">[docs]</a>
    <span class="k">def</span> <span class="nf">latticeInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print information about the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lattice name: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">latticeDim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSizeLattice</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lattice size X: &quot;</span><span class="p">,</span> <span class="n">latticeDim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lattice size Y: &quot;</span><span class="p">,</span> <span class="n">latticeDim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lattice size Z: &quot;</span><span class="p">,</span> <span class="n">latticeDim</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of beams: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberOfBeams</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of nodes: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberOfNodes</span><span class="p">())</span></div>


<div class="viewcode-block" id="Lattice.applyBoundaryConditionsOnSurface">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.applyBoundaryConditionsOnSurface">[docs]</a>
    <span class="k">def</span> <span class="nf">applyBoundaryConditionsOnSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceNames</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">valueDisplacement</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                                         <span class="n">DOF</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply boundary conditions to the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surfaceNames: list[str]</span>
<span class="sd">            List of surfaces to apply boundary conditions (e.g., [&quot;Xmin&quot;, &quot;Xmax&quot;, &quot;Ymin&quot;])</span>
<span class="sd">        valueDisplacement: list of float</span>
<span class="sd">            Displacement value to apply to the boundary conditions</span>
<span class="sd">        DOF: list of int</span>
<span class="sd">            Degree of freedom to fix (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">applyAllConstraintsOnNodes</span><span class="p">(</span><span class="n">surfaceNames</span><span class="p">,</span> <span class="n">valueDisplacement</span><span class="p">,</span> <span class="n">DOF</span><span class="p">,</span> <span class="s2">&quot;Displacement&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.applyAllConstraintsOnNodes">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.applyAllConstraintsOnNodes">[docs]</a>
    <span class="k">def</span> <span class="nf">applyAllConstraintsOnNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceNames</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">DOF</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                                   <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Displacement&quot;</span><span class="p">,</span> <span class="n">surfaceNamePoint</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply boundary conditions to the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surfaceNames: list[str]</span>
<span class="sd">            List of surfaces to apply constraint (e.g., [&quot;Xmin&quot;, &quot;Xmax&quot;, &quot;Ymin&quot;])</span>
<span class="sd">        value: list of float</span>
<span class="sd">            Values to apply to the constraint</span>
<span class="sd">        DOF: list of int</span>
<span class="sd">            Degree of freedom to apply constraint (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz)</span>
<span class="sd">        type: str</span>
<span class="sd">            Type of constraint (Displacement, Force)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">surfaceNamePoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pointSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findPointOnLatticeSurface</span><span class="p">(</span><span class="n">surfaceNames</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pointSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findPointOnLatticeSurfaceComplex</span><span class="p">(</span><span class="n">surfaceNames</span><span class="p">,</span> <span class="n">surfaceNamePoint</span><span class="p">)</span>

        <span class="n">indexBoundaryList</span> <span class="o">=</span> <span class="p">{</span><span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">pointSet</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">in</span> <span class="n">indexBoundaryList</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">DOFi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DOF</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;Displacement&quot;</span><span class="p">:</span>
                                <span class="n">node</span><span class="o">.</span><span class="n">displacementValue</span><span class="p">[</span><span class="n">DOFi</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                                <span class="n">node</span><span class="o">.</span><span class="n">fixDOF</span><span class="p">([</span><span class="n">DOFi</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;Force&quot;</span><span class="p">:</span>
                                <span class="n">node</span><span class="o">.</span><span class="n">appliedForce</span><span class="p">[</span><span class="n">DOFi</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span></div>


<div class="viewcode-block" id="Lattice.findPointOnLatticeSurface">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.findPointOnLatticeSurface">[docs]</a>
    <span class="k">def</span> <span class="nf">findPointOnLatticeSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceNames</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="s2">&quot;Point&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find points on the surface of the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surfaceNames: list[str]</span>
<span class="sd">            List of surfaces to find points on (e.g., [&quot;Xmin&quot;, &quot;Xmax&quot;, &quot;Ymin&quot;])</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        pointSet: set of Point objects</span>
<span class="sd">            Set of points found on the specified surfaces</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_surfaces</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xmin&quot;</span><span class="p">,</span> <span class="s2">&quot;Xmax&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymin&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymax&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmin&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmax&quot;</span><span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">surface</span> <span class="ow">in</span> <span class="n">valid_surfaces</span> <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="n">surfaceNames</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid surface name(s).&quot;</span><span class="p">)</span>

        <span class="n">cellLists</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCellSurface</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span> <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="n">surfaceNames</span><span class="p">]</span>
        <span class="n">cellList</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cellLists</span><span class="p">)</span>  <span class="c1"># Union of all cell indices from given surfaces</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">cellList</span><span class="p">,</span> <span class="n">default</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid cell index, some cells do not exist.&quot;</span><span class="p">)</span>

        <span class="n">pointSet</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">cellList</span><span class="p">:</span>
                <span class="n">cellPointSets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">getPointOnSurface</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span> <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="n">surfaceNames</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cellPointSets</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pointSet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">pointSet</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cellPointSets</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pointSet</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cellPointSets</span><span class="p">))</span>
        <span class="n">pointSet</span> <span class="o">=</span> <span class="n">pointSet</span> <span class="k">if</span> <span class="n">pointSet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pointSet</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No points found on the specified surfaces.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pointSet</span></div>


<div class="viewcode-block" id="Lattice.findPointOnLatticeSurfaceComplex">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.findPointOnLatticeSurfaceComplex">[docs]</a>
    <span class="k">def</span> <span class="nf">findPointOnLatticeSurfaceComplex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceNamesCell</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">surfaceNamePoint</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> \
            <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="s2">&quot;Point&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find points on the surface of the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surfaceNames: list[str]</span>
<span class="sd">            List of surfaces to find points on (e.g., [&quot;Xmin&quot;, &quot;Xmax&quot;, &quot;Ymin&quot;])</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        pointSet: set of Point objects</span>
<span class="sd">            Set of points found on the specified surfaces</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_surfaces</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Xmin&quot;</span><span class="p">,</span> <span class="s2">&quot;Xmax&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymin&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymax&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmin&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmax&quot;</span><span class="p">,</span> <span class="s2">&quot;Xmid&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymid&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmid&quot;</span><span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">surface</span> <span class="ow">in</span> <span class="n">valid_surfaces</span> <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="n">surfaceNamesCell</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid surface name(s).&quot;</span><span class="p">)</span>

        <span class="n">cellLists</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCellSurface</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span> <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="n">surfaceNamesCell</span><span class="p">]</span>
        <span class="n">cellList</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cellLists</span><span class="p">)</span>  <span class="c1"># Union of all cell indices from given surfaces</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">cellList</span><span class="p">,</span> <span class="n">default</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid cell index, some cells do not exist.&quot;</span><span class="p">)</span>

        <span class="n">pointSet</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">cellList</span><span class="p">:</span>
                <span class="n">cellPointSets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">getPointOnSurface</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span> <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="n">surfaceNamePoint</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cellPointSets</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pointSet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">pointSet</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cellPointSets</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pointSet</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cellPointSets</span><span class="p">))</span>
        <span class="n">pointSet</span> <span class="o">=</span> <span class="n">pointSet</span> <span class="k">if</span> <span class="n">pointSet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pointSet</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No points found on the specified surfaces.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pointSet</span></div>


<div class="viewcode-block" id="Lattice.applyBoundaryConditionsOnNode">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.applyBoundaryConditionsOnNode">[docs]</a>
    <span class="k">def</span> <span class="nf">applyBoundaryConditionsOnNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeList</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">valueDisplacement</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                                      <span class="n">DOF</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply boundary conditions to the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        nodeList: list of int</span>
<span class="sd">            List of node index to apply boundary conditions</span>
<span class="sd">        valueDisplacement: float</span>
<span class="sd">            Displacement value to apply to the boundary conditions</span>
<span class="sd">        DOF: int</span>
<span class="sd">            Degree of freedom to fix (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberOfNodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">nodeList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid node index, node do not exist.&quot;</span><span class="p">)</span>

        <span class="n">indexBoundaryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">node</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberOfNodes</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node index out of range.&quot;</span><span class="p">)</span>
            <span class="n">indexBoundaryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">indexBoundaryList</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">DOFi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">valueDisplacement</span><span class="p">,</span> <span class="n">DOF</span><span class="p">):</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">displacementValue</span><span class="p">[</span><span class="n">DOFi</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">fixDOF</span><span class="p">([</span><span class="n">DOFi</span><span class="p">])</span></div>


<div class="viewcode-block" id="Lattice.applyForceOnSurface">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.applyForceOnSurface">[docs]</a>
    <span class="k">def</span> <span class="nf">applyForceOnSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceName</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">valueForce</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">DOF</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply force to the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surface: str</span>
<span class="sd">            Surface to apply force (Xmin, Xmax, Ymin, Ymax, Zmin, Zmax)</span>
<span class="sd">        valueForce: list of float</span>
<span class="sd">            Force value to apply to the boundary conditions</span>
<span class="sd">        DOF: list of int</span>
<span class="sd">            List of degree of freedom to fix (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">applyAllConstraintsOnNodes</span><span class="p">(</span><span class="n">surfaceName</span><span class="p">,</span> <span class="n">valueForce</span><span class="p">,</span> <span class="n">DOF</span><span class="p">,</span> <span class="s2">&quot;Force&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.fixDOFOnSurface">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.fixDOFOnSurface">[docs]</a>
    <span class="k">def</span> <span class="nf">fixDOFOnSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceName</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">dofFixed</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix degree of freedom on the surface of the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        cellList: list of int</span>
<span class="sd">            List of cell index to apply boundary conditions</span>
<span class="sd">        surface: str</span>
<span class="sd">            Surface to apply boundary conditions (Xmin, Xmax, Ymin, Ymax, Zmin, Zmax)</span>
<span class="sd">        dofFixed: list of int</span>
<span class="sd">            List of degree of freedom to fix (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">applyAllConstraintsOnNodes</span><span class="p">(</span><span class="n">surfaceName</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dofFixed</span><span class="p">],</span> <span class="n">dofFixed</span><span class="p">,</span> <span class="s2">&quot;Displacement&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.fixDOFOnNode">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.fixDOFOnNode">[docs]</a>
    <span class="k">def</span> <span class="nf">fixDOFOnNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeList</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">dofFixed</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix degree of freedom on the surface of the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        nodeList: list of int</span>
<span class="sd">            List of node index to apply boundary conditions</span>
<span class="sd">        dofFixed: list of int</span>
<span class="sd">            List of degree of freedom to fix (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberOfNodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">nodeList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid node index, node do not exist.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">node</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberOfNodes</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node index out of range.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">nodeList</span><span class="p">:</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">fixDOF</span><span class="p">(</span><span class="n">dofFixed</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.setRandomDisplacementOnCell">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.setRandomDisplacementOnCell">[docs]</a>
    <span class="k">def</span> <span class="nf">setRandomDisplacementOnCell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set random displacement on the lattice cells</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                                <span class="n">node</span><span class="o">.</span><span class="n">displacementValue</span><span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">node</span><span class="o">.</span><span class="n">displacementValue</span><span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">fixDOF</span><span class="p">([</span><span class="n">dof</span><span class="p">])</span></div>


<div class="viewcode-block" id="Lattice.setDisplacementWithVector">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.setDisplacementWithVector">[docs]</a>
    <span class="k">def</span> <span class="nf">setDisplacementWithVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">displacementMatrix</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set displacement on the lattice with vector</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        displacementMatrix: list of float of dim n_nodes*n_dofperNode</span>
<span class="sd">            Displacement matrix to apply to the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">nodeInOrder</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">getNodeOrderToSimulate</span><span class="p">()</span>
            <span class="n">idxNode</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodeInOrder</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">displacementValue</span> <span class="o">=</span> <span class="n">displacementMatrix</span><span class="p">[</span><span class="n">idxNode</span><span class="p">]</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">fixDOF</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)])</span>
                    <span class="n">idxNode</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Lattice.getDisplacementGlobal">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getDisplacementGlobal">[docs]</a>
    <span class="k">def</span> <span class="nf">getDisplacementGlobal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">withFixed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">OnlyImposed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">printLevel</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get global displacement of the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        withFixed: bool</span>
<span class="sd">            If True, return displacement of all nodes, else return only free degree of freedom</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        globalDisplacement: dict</span>
<span class="sd">            Dictionary of global displacement with indexBoundary as key and displacement vector as value</span>
<span class="sd">        globalDisplacementIndex: list of int</span>
<span class="sd">            List of indexBoundary of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">globalDisplacement</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">globalDisplacementIndex</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">processed_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed_nodes</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">fixedDOF</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">OnlyImposed</span><span class="p">:</span>
                                <span class="n">globalDisplacement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">displacementValue</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                <span class="n">globalDisplacementIndex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">fixedDOF</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">appliedForce</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">globalDisplacement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">withFixed</span> <span class="ow">or</span> <span class="n">OnlyImposed</span><span class="p">:</span>
                                <span class="n">globalDisplacement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">displacementValue</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                <span class="n">globalDisplacementIndex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">)</span>

                        <span class="n">processed_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">OnlyImposed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">globalDisplacementIndex</span> <span class="o">=</span> <span class="n">globalDisplacementIndex</span>
        <span class="k">if</span> <span class="n">printLevel</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;globalDisplacement: &quot;</span><span class="p">,</span> <span class="n">globalDisplacement</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;globalDisplacementIndex: &quot;</span><span class="p">,</span> <span class="n">globalDisplacementIndex</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">globalDisplacement</span><span class="p">,</span> <span class="n">globalDisplacementIndex</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">defineNodeIndexBoundary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define boundary tag for all boundary nodes and calculate the total number of boundary nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">IndexCounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nodeAlreadyIndexed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">localTag</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tagPoint</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">getCellBoundaryBox</span><span class="p">())</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">setLocalTag</span><span class="p">(</span><span class="n">localTag</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">localTag</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeAlreadyIndexed</span><span class="p">:</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="o">=</span> <span class="n">nodeAlreadyIndexed</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">nodeAlreadyIndexed</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">IndexCounter</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="o">=</span> <span class="n">IndexCounter</span>
                            <span class="n">IndexCounter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxIndexBoundary</span> <span class="o">=</span> <span class="n">IndexCounter</span> <span class="o">-</span> <span class="mi">1</span>

<div class="viewcode-block" id="Lattice.setPointLocalTag">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.setPointLocalTag">[docs]</a>
    <span class="k">def</span> <span class="nf">setPointLocalTag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set local tag for all points in the lattice based on their position within the cell boundary box.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">localTag</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tagPoint</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">getCellBoundaryBox</span><span class="p">())</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">setLocalTag</span><span class="p">(</span><span class="n">localTag</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.getGlobalReactionForce">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getGlobalReactionForce">[docs]</a>
    <span class="k">def</span> <span class="nf">getGlobalReactionForce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appliedForceAdded</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get local reaction force of the lattice and sum if identical TagIndex</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        globalReactionForce: dict</span>
<span class="sd">            Dictionary of global reaction force with indexBoundary as key and reaction force vector as value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">globalReactionForce</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxIndexBoundary</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">nodeIndexProcessed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeIndexProcessed</span><span class="p">:</span>
                        <span class="n">globalReactionForce</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">globalReactionForce</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">],</span> <span class="n">node</span><span class="o">.</span><span class="n">reactionForceValue</span><span class="p">)</span>
                        <span class="p">]</span>
                        <span class="k">if</span> <span class="n">appliedForceAdded</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">appliedForce</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">globalReactionForce</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">appliedForce</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">nodeIndexProcessed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">globalReactionForce</span></div>


<div class="viewcode-block" id="Lattice.getGlobalReactionForceWithoutFixedDOF">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getGlobalReactionForceWithoutFixedDOF">[docs]</a>
    <span class="k">def</span> <span class="nf">getGlobalReactionForceWithoutFixedDOF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">globalReactionForce</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">rightHandSide</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get global reaction force of free degree of freedom</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        globalReactionForce: dict</span>
<span class="sd">            Dictionary of global reaction force with indexBoundary as key and reaction force vector as value</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        globalReactionForceWithoutFixedDOF: np.ndarray</span>
<span class="sd">            Array of global reaction force without fixed degree of freedom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">globalReactionForceWithoutFixedDOF</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">processed_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed_nodes</span><span class="p">:</span>
                        <span class="c1"># Append reaction force components where fixedDOF is 0</span>
                        <span class="n">RFToAdd</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">appliedForce</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">rightHandSide</span><span class="p">:</span>
                                <span class="n">RFToAdd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">node</span><span class="o">.</span><span class="n">appliedForce</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                <span class="c1"># Add a sign minus because right-hand side already with a sign minus see (b = -b)</span>
                            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">fixedDOF</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">RFToAdd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">globalReactionForce</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">globalReactionForceWithoutFixedDOF</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">RFToAdd</span><span class="p">)</span>
                        <span class="c1"># globalReactionForceWithoutFixedDOF.append([</span>
                        <span class="c1">#     v1 for v1, v2 in zip(globalReactionForce[node.indexBoundary], node.fixedDOF)</span>
                        <span class="c1">#     if v2 == 0])</span>
                        <span class="c1"># print(globalReactionForceWithoutFixedDOF[-1])</span>
                        <span class="c1"># Mark this node as processed</span>
                        <span class="n">processed_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">globalReactionForceWithoutFixedDOF</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.setFreeDOF">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.setFreeDOF">[docs]</a>
    <span class="k">def</span> <span class="nf">setFreeDOF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get total number of degrees of freedom in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freeDOF</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">processed_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed_nodes</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">freeDOF</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="n">fixedDOF</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">processed_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.setGlobalFreeDOFIndex">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.setGlobalFreeDOFIndex">[docs]</a>
    <span class="k">def</span> <span class="nf">setGlobalFreeDOFIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set global free degree of freedom index for all nodes in boundary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">processed_nodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed_nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">fixedDOF</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">node</span><span class="o">.</span><span class="n">globalFreeDOFIndex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span>
                                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">processed_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">globalFreeDOFIndex</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">globalFreeDOFIndex</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">processed_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">]</span></div>


<div class="viewcode-block" id="Lattice.initializeReactionForce">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.initializeReactionForce">[docs]</a>
    <span class="k">def</span> <span class="nf">initializeReactionForce</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize reaction force of all nodes to 0 on each DOF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">initializeReactionForce</span><span class="p">()</span></div>


<div class="viewcode-block" id="Lattice.initializeDisplacementToZero">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.initializeDisplacementToZero">[docs]</a>
    <span class="k">def</span> <span class="nf">initializeDisplacementToZero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize displacement of all nodes to zero on each DOF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">initializeDisplacementToZero</span><span class="p">()</span></div>


<div class="viewcode-block" id="Lattice.buildCouplingOperatorForEachCells">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.buildCouplingOperatorForEachCells">[docs]</a>
    <span class="k">def</span> <span class="nf">buildCouplingOperatorForEachCells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build coupling operator for each cell in the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">buildCouplingOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freeDOF</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.buildLUSchurComplement">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.buildLUSchurComplement">[docs]</a>
    <span class="k">def</span> <span class="nf">buildLUSchurComplement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictSchurComplement</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">splu</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build LU decomposition of the Schur complement matrix for the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        schurComplementMatrix: coo_matrix</span>
<span class="sd">            Schur complement matrix of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ConjugateGradientMethod.Utils_Schur</span> <span class="kn">import</span> <span class="n">loadSchurComplement</span><span class="p">,</span> <span class="n">getSref_nearest</span>

        <span class="k">if</span> <span class="n">dictSchurComplement</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nameFileSchur</span> <span class="o">=</span> <span class="s2">&quot;ConjugateGradientMethod/schurComplement/Hybrid_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;.npz&quot;</span>
            <span class="n">dictSchurComplement</span> <span class="o">=</span> <span class="n">loadSchurComplement</span><span class="p">(</span><span class="n">nameFileSchur</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">buildCouplingOperatorForEachCells</span><span class="p">()</span>
        <span class="n">globalSchurComplement</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">freeDOF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freeDOF</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">schurComplementMatrix</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">(</span><span class="n">getSref_nearest</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">SchurDict</span><span class="o">=</span><span class="n">dictSchurComplement</span><span class="p">,</span>
                                                               <span class="n">printing</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="n">globalSchurComplement</span> <span class="o">+=</span> <span class="n">cell</span><span class="o">.</span><span class="n">buildPreconditioner</span><span class="p">(</span><span class="n">schurComplementMatrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">globalSchurComplement</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attention : There are some rows with all zeros in the Schur complement matrix.&quot;</span><span class="p">)</span>
        <span class="n">cond_number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">globalSchurComplement</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Condition number of the Schur complement matrix: &quot;</span><span class="p">,</span> <span class="n">cond_number</span><span class="p">)</span>

        <span class="c1"># Factorize preconditioner</span>
        <span class="n">LUSchurComplement</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">inverseSchurComplement</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">cond_number</span> <span class="o">&gt;</span> <span class="mf">1e15</span><span class="p">:</span>
            <span class="n">inverseSchurComplement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">globalSchurComplement</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
            <span class="c1"># inverseSchurComplement = None</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using pseudo-inverse of the Schur complement matrix.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">globalSchurComplement</span> <span class="o">=</span> <span class="n">globalSchurComplement</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
            <span class="n">LUSchurComplement</span> <span class="o">=</span> <span class="n">splu</span><span class="p">(</span><span class="n">globalSchurComplement</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using LU decomposition of the Schur complement matrix.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LUSchurComplement</span><span class="p">,</span> <span class="n">inverseSchurComplement</span></div>


<div class="viewcode-block" id="Lattice.getCellSurface">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getCellSurface">[docs]</a>
    <span class="k">def</span> <span class="nf">getCellSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a cell list on the surface of the lattice.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surface: str</span>
<span class="sd">            Surface to get points (&quot;Xmin&quot;, &quot;Xmax&quot;, &quot;Ymin&quot;, &quot;Ymax&quot;, &quot;Zmin&quot;, &quot;Zmax&quot;, &quot;Xmid&quot;, &quot;Ymid&quot;, &quot;Zmid&quot;)</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        cellTagList: list of cell index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_surfaces</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Xmin&quot;</span><span class="p">,</span> <span class="s2">&quot;Xmax&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymin&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymax&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmin&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmax&quot;</span><span class="p">,</span> <span class="s2">&quot;Xmid&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymid&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmid&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">surface</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_surfaces</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid surface name.&quot;</span><span class="p">)</span>

        <span class="n">mid_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Xmid&quot;</span><span class="p">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xMin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMax</span><span class="p">),</span>
            <span class="s2">&quot;Ymid&quot;</span><span class="p">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yMin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMax</span><span class="p">),</span>
            <span class="s2">&quot;Zmid&quot;</span><span class="p">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zMin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMax</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="n">surface_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Xmin&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMin</span><span class="p">),</span>
            <span class="s2">&quot;Xmax&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMax</span><span class="p">),</span>
            <span class="s2">&quot;Ymin&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMin</span><span class="p">),</span>
            <span class="s2">&quot;Ymax&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMax</span><span class="p">),</span>
            <span class="s2">&quot;Zmin&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMin</span><span class="p">),</span>
            <span class="s2">&quot;Zmax&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMax</span><span class="p">),</span>
            <span class="s2">&quot;Xmid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">mid_dict</span><span class="p">[</span><span class="s2">&quot;Xmid&quot;</span><span class="p">]),</span>
            <span class="s2">&quot;Ymid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">mid_dict</span><span class="p">[</span><span class="s2">&quot;Ymid&quot;</span><span class="p">]),</span>
            <span class="s2">&quot;Zmid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="n">mid_dict</span><span class="p">[</span><span class="s2">&quot;Zmid&quot;</span><span class="p">])</span>
        <span class="p">}</span>

        <span class="n">axis</span><span class="p">,</span> <span class="n">valueSurface</span> <span class="o">=</span> <span class="n">surface_dict</span><span class="p">[</span><span class="n">surface</span><span class="p">]</span>

        <span class="n">cellTagList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">listPointOnSurface</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">getPointOnSurface</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">listPointOnSurface</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="n">valueSurface</span><span class="p">:</span>
                    <span class="n">cellTagList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">cellTagList</span></div>


<div class="viewcode-block" id="Lattice.getRadius">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getRadius">[docs]</a>
    <span class="k">def</span> <span class="nf">getRadius</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ################### TEMPORARY FUNCTION ###################</span>
<span class="sd">        Get the radius of the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        radius: float</span>
<span class="sd">            radii of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span></div>


<div class="viewcode-block" id="Lattice.unnormalize_r">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.unnormalize_r">[docs]</a>
    <span class="k">def</span> <span class="nf">unnormalize_r</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r_norm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Denormalize optimization parameters</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        r_norm: float</span>
<span class="sd">            Normalized optimization parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span>
        <span class="k">return</span> <span class="n">r_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">r_max</span> <span class="o">-</span> <span class="n">r_min</span><span class="p">)</span> <span class="o">*</span> <span class="n">r_norm</span>  <span class="c1"># D√©-normalisation</span></div>


<div class="viewcode-block" id="Lattice.setOptimizationParameters">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.setOptimizationParameters">[docs]</a>
    <span class="k">def</span> <span class="nf">setOptimizationParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optimizationParameters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">geomScheme</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set optimization parameters for the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        optimizationParameters: list of float</span>
<span class="sd">            List of optimization parameters</span>
<span class="sd">        geomScheme: list of bool</span>
<span class="sd">            List of N boolean values indicating the scheme of geometry to optimize</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">optimizationParameters</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberParametersOptimization</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid number of optimization parameters.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geomScheme</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">numberOfParametersPerCell</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numberOfParametersPerCell</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">startIdx</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="o">*</span> <span class="n">numberOfParametersPerCell</span>
            <span class="n">endIdx</span> <span class="o">=</span> <span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">numberOfParametersPerCell</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">optimizationParameters</span><span class="p">[</span><span class="n">startIdx</span><span class="p">:</span><span class="n">endIdx</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">radius</span><span class="p">):</span>
                <span class="c1"># Reconstruct the full radius vector based on geomScheme</span>
                <span class="n">full_radius</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># index for radius (optimization vector)</span>
                <span class="k">for</span> <span class="n">keep</span><span class="p">,</span> <span class="n">old</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">radius</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
                        <span class="n">full_radius</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">radius</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">full_radius</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="n">full_radius</span>

            <span class="n">cell</span><span class="o">.</span><span class="n">changeBeamRadius</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradRadius</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.calculateObjective">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.calculateObjective">[docs]</a>
    <span class="k">def</span> <span class="nf">calculateObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeObjective</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate objective function for the lattice optimization</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeObjective: str</span>
<span class="sd">            Type of objective function to calculate (Compliance...)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        objectiveValue: float</span>
<span class="sd">            Objective function value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">typeObjective</span> <span class="o">==</span> <span class="s2">&quot;Compliance&quot;</span><span class="p">:</span>
            <span class="n">reactionForce</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGlobalReactionForce</span><span class="p">(</span><span class="n">appliedForceAdded</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">reaction_force_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">reactionForce</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getDisplacementGlobal</span><span class="p">(</span><span class="n">OnlyImposed</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">objective</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">reaction_force_array</span><span class="p">,</span> <span class="n">displacement</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reaction force: &quot;</span><span class="p">,</span> <span class="n">reaction_force_array</span><span class="p">[</span><span class="n">displacement</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Displacement: &quot;</span><span class="p">,</span> <span class="n">displacement</span><span class="p">[</span><span class="n">displacement</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Compliance: &quot;</span><span class="p">,</span> <span class="n">objective</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">typeObjective</span> <span class="o">==</span> <span class="s2">&quot;Displacement&quot;</span><span class="p">:</span>
            <span class="n">setNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findPointOnLatticeSurface</span><span class="p">(</span><span class="n">surfaceNames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">objectifData</span><span class="p">[</span><span class="s2">&quot;surface&quot;</span><span class="p">])</span>
            <span class="n">displacements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">setNode</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objectifData</span><span class="p">[</span><span class="s2">&quot;DOF&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">dof</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dof</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid degree of freedom index.&quot;</span><span class="p">)</span>
                    <span class="n">displacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">displacementValue</span><span class="p">[</span><span class="n">dof</span><span class="p">])</span>
            <span class="n">displacements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">displacements</span><span class="p">)</span>
            <span class="n">objective</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">displacements</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">displacements</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">typeObjective</span> <span class="o">==</span> <span class="s2">&quot;Stiffness&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">objective</span></div>


<div class="viewcode-block" id="Lattice.getNumberParametersOptimization">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getNumberParametersOptimization">[docs]</a>
    <span class="k">def</span> <span class="nf">getNumberParametersOptimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geomScheme</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get number of parameters for optimization</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        numParameters: int</span>
<span class="sd">            Number of parameters for optimization</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numParameters</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">geomScheme</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">numParameters</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numParameters</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numParameters</span></div>


<div class="viewcode-block" id="Lattice.applyReactionForceOnNodeList">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.applyReactionForceOnNodeList">[docs]</a>
    <span class="k">def</span> <span class="nf">applyReactionForceOnNodeList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionForce</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">nodeCoordinatesList</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply reaction force on node list</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        reactionForce: list of float</span>
<span class="sd">            Reaction force to apply</span>
<span class="sd">        nodeCoordinatesList: list of float</span>
<span class="sd">            Coordinates of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodeCoordinatesArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodeCoordinatesList</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">nodeCoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nodeCoordinatesArray</span> <span class="o">==</span> <span class="n">nodeCoord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">match</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">setReactionForce</span><span class="p">(</span><span class="n">reactionForce</span><span class="p">[</span><span class="n">index</span><span class="p">])</span></div>


<div class="viewcode-block" id="Lattice.applyDisplacementOnNodeList">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.applyDisplacementOnNodeList">[docs]</a>
    <span class="k">def</span> <span class="nf">applyDisplacementOnNodeList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">displacement</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">nodeCoordinatesList</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply displacement on node list</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        displacement: list of float</span>
<span class="sd">            Displacement to apply</span>
<span class="sd">        nodeCoordinatesList: list of float</span>
<span class="sd">            Coordinates of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodeCoordinatesArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodeCoordinatesList</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="n">nodeCoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nodeCoordinatesArray</span> <span class="o">==</span> <span class="n">nodeCoord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">match</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">displacementValue</span> <span class="o">=</span> <span class="n">displacement</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">fixDOF</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)])</span></div>


<div class="viewcode-block" id="Lattice.expandSchurToFullBasis">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.expandSchurToFullBasis">[docs]</a>
    <span class="k">def</span> <span class="nf">expandSchurToFullBasis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SchurReduced</span><span class="p">,</span> <span class="n">nodeInOrder</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand the reduced Schur complement matrix into the full 156-DOF boundary space.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        SchurReduced : np.ndarray</span>
<span class="sd">            The Schur complement matrix computed only for the active boundary nodes.</span>
<span class="sd">        nodeInOrder : dict</span>
<span class="sd">            Dictionary with node tags as keys and corresponding node objects as values.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        SchurFull : np.ndarray</span>
<span class="sd">            The expanded Schur complement matrix in the full 156-DOF boundary space.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">num_total_boundary_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodeInOrder</span><span class="p">)</span>  <span class="c1"># Nombre total de n≈ìuds fronti√®re</span>
        <span class="n">total_dofs</span> <span class="o">=</span> <span class="n">num_total_boundary_nodes</span> <span class="o">*</span> <span class="mi">6</span>  <span class="c1"># Chaque n≈ìud a 6 DOFs</span>
        <span class="n">SchurFull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">total_dofs</span><span class="p">,</span> <span class="n">total_dofs</span><span class="p">))</span>  <span class="c1"># Matrice compl√®te initialis√©e √† z√©ro</span>

        <span class="c1"># Construire un mapping entre les indices de SchurReduced et les indices globaux</span>
        <span class="n">boundary_dof_map</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Associe index local -&gt; index global dans SchurFull</span>
        <span class="n">dof_counter</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Compteur pour attribuer des indices locaux √† la matrice r√©duite</span>

        <span class="k">for</span> <span class="n">node_idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodeInOrder</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Le n≈ìud est utilis√©</span>
                <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>  <span class="c1"># Chaque n≈ìud a 6 DOFs</span>
                    <span class="n">boundary_dof_map</span><span class="p">[</span><span class="n">dof_counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_idx</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">dof</span>
                    <span class="n">dof_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Remplir SchurFull en utilisant les indices mapp√©s</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">SchurReduced</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">global_i</span> <span class="o">=</span> <span class="n">boundary_dof_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># Trouver l&#39;index global correspondant</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">SchurReduced</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">global_j</span> <span class="o">=</span> <span class="n">boundary_dof_map</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">SchurFull</span><span class="p">[</span><span class="n">global_i</span><span class="p">,</span> <span class="n">global_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">SchurReduced</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">SchurFull</span></div>


<div class="viewcode-block" id="Lattice.printStatistics">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.printStatistics">[docs]</a>
    <span class="k">def</span> <span class="nf">printStatistics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print statistics about the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of cells: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of beams: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberOfBeams</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of nodes: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberOfNodes</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Relative density: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRelativeDensity</span><span class="p">())</span>
        <span class="n">radMax</span><span class="p">,</span> <span class="n">radMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRadiusMinMax</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;radii max: &quot;</span><span class="p">,</span> <span class="n">radMax</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;radii min: &quot;</span><span class="p">,</span> <span class="n">radMin</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.getRadiusMinMax">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.getRadiusMinMax">[docs]</a>
    <span class="k">def</span> <span class="nf">getRadiusMinMax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the maximum and minimum radius of the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        radMax: float</span>
<span class="sd">            Maximum radius of the lattice</span>
<span class="sd">        radMin: float</span>
<span class="sd">            Minimum radius of the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">radMin</span> <span class="o">=</span> <span class="mi">1000000</span>
        <span class="n">radMax</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">beam</span><span class="o">.</span><span class="n">modBeam</span><span class="p">:</span>
                    <span class="n">radMin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">radMin</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
                    <span class="n">radMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">radMax</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">radMax</span><span class="p">,</span> <span class="n">radMin</span></div>


<div class="viewcode-block" id="Lattice.addMeshObject">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.addMeshObject">[docs]</a>
    <span class="k">def</span> <span class="nf">addMeshObject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meshObject</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a mesh object to the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        meshObject: MeshObject</span>
<span class="sd">            Mesh object to add to the lattice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshObject</span> <span class="o">=</span> <span class="n">meshObject</span></div>


<div class="viewcode-block" id="Lattice.cutBeamsAtMeshIntersection">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.cutBeamsAtMeshIntersection">[docs]</a>
    <span class="k">def</span> <span class="nf">cutBeamsAtMeshIntersection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cut beams at the intersection with the mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshObject</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A mesh object must be assigned to the lattice before cutting beams.&quot;</span><span class="p">)</span>

        <span class="n">new_beams</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">beams_to_remove</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">beam</span><span class="o">.</span><span class="n">modBeam</span><span class="p">:</span>
                    <span class="n">p1_inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshObject</span><span class="o">.</span><span class="n">is_inside_mesh</span><span class="p">([</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
                    <span class="n">p2_inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshObject</span><span class="o">.</span><span class="n">is_inside_mesh</span><span class="p">([</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">p1_inside</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">p2_inside</span><span class="p">:</span>
                        <span class="c1"># The Beam is outside the mesh, remove it</span>
                        <span class="n">beams_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">p1_inside</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">p2_inside</span><span class="p">:</span>
                        <span class="c1"># The Beam intersects the mesh, cut it</span>
                        <span class="n">intersection_point</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">findIntersectionWithMesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshObject</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">intersection_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">new_point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">intersection_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intersection_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">intersection_point</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

                            <span class="k">if</span> <span class="ow">not</span> <span class="n">p1_inside</span><span class="p">:</span>
                                <span class="n">new_beam</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">new_point</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">new_beam</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">new_point</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

                            <span class="n">new_beams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_beam</span><span class="p">)</span>
                            <span class="n">beams_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cutting is only available for non modified lattice.&quot;</span><span class="p">)</span>
            <span class="c1"># Apply changes</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">beams_to_remove</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">removeBeam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">new_beams</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">addBeam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>

            <span class="n">new_beams</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">beams_to_remove</span> <span class="o">=</span> <span class="p">[]</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">applySymmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symmetry_plane</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">reference_point</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply symmetry to the lattice structure based on a reference point.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        symmetry_plane : str</span>
<span class="sd">            The plane of symmetry, can be &quot;XY&quot;, &quot;XZ&quot;, &quot;YZ&quot; (default symmetries),</span>
<span class="sd">            or &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; for symmetry about a specific coordinate.</span>
<span class="sd">        reference_point : tuple (x_ref, y_ref, z_ref), optional</span>
<span class="sd">            The reference point for the symmetry. Defaults to (0,0,0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">symmetry_plane</span> <span class="o">=</span> <span class="n">symmetry_plane</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">symmetry_plane</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="s2">&quot;XZ&quot;</span><span class="p">,</span> <span class="s2">&quot;YZ&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid symmetry plane. Choose from &#39;XY&#39;, &#39;XZ&#39;, &#39;YZ&#39;, &#39;X&#39;, &#39;Y&#39;, or &#39;Z&#39;.&quot;</span><span class="p">)</span>

        <span class="n">x_ref</span><span class="p">,</span> <span class="n">y_ref</span><span class="p">,</span> <span class="n">z_ref</span> <span class="o">=</span> <span class="n">reference_point</span>
        <span class="n">new_cells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">node_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">new_pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">posCell</span><span class="p">)</span>
            <span class="n">new_start_pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">)</span>
            <span class="n">mirrored_beams</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="n">new_point1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
                <span class="n">new_point2</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

                <span class="c1"># Apply symmetry transformation based on the selected plane</span>
                <span class="k">if</span> <span class="n">symmetry_plane</span> <span class="o">==</span> <span class="s2">&quot;XY&quot;</span><span class="p">:</span>
                    <span class="n">new_point1</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_ref</span> <span class="o">-</span> <span class="n">new_point1</span><span class="o">.</span><span class="n">z</span>
                    <span class="n">new_point2</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_ref</span> <span class="o">-</span> <span class="n">new_point2</span><span class="o">.</span><span class="n">z</span>
                    <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_ref</span> <span class="o">-</span> <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symmetry_plane</span> <span class="o">==</span> <span class="s2">&quot;XZ&quot;</span><span class="p">:</span>
                    <span class="n">new_point1</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_ref</span> <span class="o">-</span> <span class="n">new_point1</span><span class="o">.</span><span class="n">y</span>
                    <span class="n">new_point2</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_ref</span> <span class="o">-</span> <span class="n">new_point2</span><span class="o">.</span><span class="n">y</span>
                    <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_ref</span> <span class="o">-</span> <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symmetry_plane</span> <span class="o">==</span> <span class="s2">&quot;YZ&quot;</span><span class="p">:</span>
                    <span class="n">new_point1</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ref</span> <span class="o">-</span> <span class="n">new_point1</span><span class="o">.</span><span class="n">x</span>
                    <span class="n">new_point2</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ref</span> <span class="o">-</span> <span class="n">new_point2</span><span class="o">.</span><span class="n">x</span>
                    <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ref</span> <span class="o">-</span> <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symmetry_plane</span> <span class="o">==</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
                    <span class="n">new_point1</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ref</span> <span class="o">-</span> <span class="n">new_point1</span><span class="o">.</span><span class="n">x</span>
                    <span class="n">new_point2</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ref</span> <span class="o">-</span> <span class="n">new_point2</span><span class="o">.</span><span class="n">x</span>
                    <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ref</span> <span class="o">-</span> <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symmetry_plane</span> <span class="o">==</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span>
                    <span class="n">new_point1</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_ref</span> <span class="o">-</span> <span class="n">new_point1</span><span class="o">.</span><span class="n">y</span>
                    <span class="n">new_point2</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_ref</span> <span class="o">-</span> <span class="n">new_point2</span><span class="o">.</span><span class="n">y</span>
                    <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_ref</span> <span class="o">-</span> <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symmetry_plane</span> <span class="o">==</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
                    <span class="n">new_point1</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_ref</span> <span class="o">-</span> <span class="n">new_point1</span><span class="o">.</span><span class="n">z</span>
                    <span class="n">new_point2</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_ref</span> <span class="o">-</span> <span class="n">new_point2</span><span class="o">.</span><span class="n">z</span>
                    <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_ref</span> <span class="o">-</span> <span class="n">new_start_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                <span class="c1"># Ensure uniqueness of nodes</span>
                <span class="k">if</span> <span class="n">new_point1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_map</span><span class="p">:</span>
                    <span class="n">node_map</span><span class="p">[</span><span class="n">new_point1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_point1</span>
                <span class="k">if</span> <span class="n">new_point2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_map</span><span class="p">:</span>
                    <span class="n">node_map</span><span class="p">[</span><span class="n">new_point2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_point2</span>

                <span class="n">mirrored_beams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Beam</span><span class="p">(</span><span class="n">node_map</span><span class="p">[</span><span class="n">new_point1</span><span class="p">],</span> <span class="n">node_map</span><span class="p">[</span><span class="n">new_point2</span><span class="p">],</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">material</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>

            <span class="c1"># Create a new mirrored cell</span>
            <span class="n">new_cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">new_pos</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">cellSize</span><span class="p">,</span> <span class="n">new_start_pos</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">geom_types</span><span class="p">,</span>
                            <span class="n">cell</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">gradRadius</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">gradDim</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">gradMat</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">uncertaintyNode</span><span class="p">)</span>

            <span class="n">new_cell</span><span class="o">.</span><span class="n">beams</span> <span class="o">=</span> <span class="n">mirrored_beams</span>
            <span class="n">new_cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_cells</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getMinMaxValues</span><span class="p">()</span>  <span class="c1"># Recalculate the lattice boundaries</span>

    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">loadRelativeDensityModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="s2">&quot;Lattice/Saved_Lattice/RelativeDensityKrigingModel.pkl&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the relative density model from a file</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        model_path: str</span>
<span class="sd">            Path to the model file</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        model: Kriging</span>
<span class="sd">            The loaded model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">model_path</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model file not found: </span><span class="si">{</span><span class="n">model_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gpr</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krigingModelRelativeDensity</span> <span class="o">=</span> <span class="n">gpr</span>

<div class="viewcode-block" id="Lattice.deleteBeamsUnderThreshold">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.deleteBeamsUnderThreshold">[docs]</a>
    <span class="k">def</span> <span class="nf">deleteBeamsUnderThreshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete beams with radius under a certain threshold</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        threshold: float</span>
<span class="sd">            Threshold value for beam radius</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">beamsToRemove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">:</span>
                    <span class="n">beamsToRemove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">beamsToRemove</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">removeBeam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.deleteBeamsGeomScheme">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.deleteBeamsGeomScheme">[docs]</a>
    <span class="k">def</span> <span class="nf">deleteBeamsGeomScheme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geomScheme</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete beams based on the geometry scheme.</span>
<span class="sd">        If geomScheme[i] is False, the beam of type i will be removed.</span>
<span class="sd">        Usefull for hybrid lattices geometry.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        geomScheme: list of bool</span>
<span class="sd">            List of N boolean values indicating the scheme of geometry to optimize</span>
<span class="sd">            If geomScheme[i] is False, the beam of type i will be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">beamsToRemove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">geomScheme</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">]:</span>
                    <span class="n">beamsToRemove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">beamsToRemove</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">removeBeam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lattice.setObjectiveData">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.setObjectiveData">[docs]</a>
    <span class="k">def</span> <span class="nf">setObjectiveData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objectifData</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add objective data to the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        objectifData: dict</span>
<span class="sd">            Dictionary containing objective data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objectifData</span> <span class="o">=</span> <span class="n">objectifData</span></div>


    <span class="nd">@timing</span><span class="o">.</span><span class="n">timeit</span>
    <span class="k">def</span> <span class="nf">generateMeshLatticeGmsh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutMeshAtBoundary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">meshSize</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">runGmshApp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span>
                                <span class="kc">False</span><span class="p">,</span> <span class="n">saveMesh</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">nameMesh</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Lattice&quot;</span><span class="p">,</span> <span class="n">saveSTL</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a mesh representation of the lattice structure using GMSH.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        cutMeshAtBoundary: bool</span>
<span class="sd">            If True, cut the mesh at the bounding box of the lattice.</span>
<span class="sd">        meshSize: float</span>
<span class="sd">            Size of the mesh elements.</span>
<span class="sd">        runGmshApp: bool</span>
<span class="sd">            If True, run the GMSH application to visualize the mesh.</span>
<span class="sd">        saveMesh: bool</span>
<span class="sd">            If True, save the mesh to a file.</span>
<span class="sd">        nameMesh: str</span>
<span class="sd">            Name of the mesh file to save.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_simulation_properties</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mesh generation is not available for the current simulation method.&quot;</span><span class="p">)</span>

        <span class="n">gmsh</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
        <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nameMesh</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Dimension of the mesh</span>

        <span class="n">all_tags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="o">.</span><span class="n">getPos</span><span class="p">())</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="o">.</span><span class="n">getPos</span><span class="p">())</span>
                <span class="n">direction</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_tags</span><span class="p">:</span>
                    <span class="n">beamMesh</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCylinder</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="o">*</span><span class="n">direction</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">beam</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                    <span class="n">all_tags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beamMesh</span><span class="p">)</span>

        <span class="c1"># Merge all beams into a single entity</span>
        <span class="n">beam_entities</span> <span class="o">=</span> <span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">all_tags</span><span class="p">]</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">fragment</span><span class="p">(</span><span class="n">beam_entities</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">if</span> <span class="n">cutMeshAtBoundary</span><span class="p">:</span>
            <span class="c1"># Bounding box definition</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMin</span>
            <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMax</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yMax</span> <span class="o">-</span> <span class="n">y0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zMax</span> <span class="o">-</span> <span class="n">z0</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addBox</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">)</span>
            <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">box</span><span class="p">)],</span> <span class="n">removeObject</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

        <span class="c1"># Define mesh size</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">getEntities</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">setSize</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">meshSize</span><span class="p">)</span>
        <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

        <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">runGmshApp</span><span class="p">:</span>
            <span class="n">gmsh</span><span class="o">.</span><span class="n">fltk</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

        <span class="n">saving_path</span> <span class="o">=</span> <span class="s2">&quot;Mesh/&quot;</span>
        <span class="k">if</span> <span class="n">saveMesh</span><span class="p">:</span>
            <span class="n">gmsh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">saving_path</span> <span class="o">+</span> <span class="n">nameMesh</span> <span class="o">+</span> <span class="s2">&quot;.msh&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh saved as &quot;</span><span class="p">,</span> <span class="n">nameMesh</span> <span class="o">+</span> <span class="s2">&quot;.msh&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">saveSTL</span><span class="p">:</span>
            <span class="n">gmsh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">saving_path</span> <span class="o">+</span> <span class="n">nameMesh</span> <span class="o">+</span> <span class="s2">&quot;.stl&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh saved as &quot;</span><span class="p">,</span> <span class="n">nameMesh</span> <span class="o">+</span> <span class="s2">&quot;.stl&quot;</span><span class="p">)</span>

        <span class="n">gmsh</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

<div class="viewcode-block" id="Lattice.are_cells_identical">
<a class="viewcode-back" href="../../src.html#src.Lattice.Lattice.are_cells_identical">[docs]</a>
    <span class="k">def</span> <span class="nf">are_cells_identical</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if all cells in the list are identical based on their attributes and beams.</span>
<span class="sd">        Print the result.</span>
<span class="sd">        Possible upgrade could be to use a more sophisticated comparison method (Only beam length is checked for now).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">Fore</span><span class="o">.</span><span class="n">GREEN</span> <span class="o">+</span> <span class="s2">&quot;Only one or no cell: considered identical.&quot;</span> <span class="o">+</span> <span class="n">Style</span><span class="o">.</span><span class="n">RESET_ALL</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">reference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">attrs_to_check</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;geom_types&quot;</span><span class="p">,</span>
            <span class="s2">&quot;radius&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cellSize&quot;</span><span class="p">,</span>
            <span class="s2">&quot;gradRadius&quot;</span><span class="p">,</span>
            <span class="s2">&quot;gradDim&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs_to_check</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">attr</span><span class="p">)):</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="n">Fore</span><span class="o">.</span><span class="n">RED</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;Difference found in attribute &#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&#39; between cell 0 and cell </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">Style</span><span class="o">.</span><span class="n">RESET_ALL</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">beams</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">Fore</span><span class="o">.</span><span class="n">RED</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;Different number of beams between cell 0 and cell </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">Style</span><span class="o">.</span><span class="n">RESET_ALL</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">beams</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">beams</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">b1</span><span class="o">.</span><span class="n">is_identical_to</span><span class="p">(</span><span class="n">b2</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">Fore</span><span class="o">.</span><span class="n">RED</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;Difference found in beam </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> between cell 0 and cell </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">Style</span><span class="o">.</span><span class="n">RESET_ALL</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">Fore</span><span class="o">.</span><span class="n">GREEN</span> <span class="o">+</span> <span class="s2">&quot;All cells are identical.&quot;</span> <span class="o">+</span> <span class="n">Style</span><span class="o">.</span><span class="n">RESET_ALL</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Thomas Cadart.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>